<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>BERE'SHIYTH: In The Beginning</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #111827;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      -webkit-user-select: none;
      user-select: none;
      touch-action: manipulation;
    }
    #root { width: 100%; height: 100vh; }
    /* Canvas fills the whole screen; all UI floats on top */
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    /* ── overlaid UI ─────────────────────────────────────── */
    .title {
      position: absolute;
      top: 8px; left: 50%; transform: translateX(-50%);
      font-size: 1rem;
      font-weight: bold;
      color: #facc15;
      font-family: Georgia, serif;
      text-shadow: 0 1px 4px #000;
      pointer-events: none;
      white-space: nowrap;
      z-index: 10;
    }
    .dialogue-box {
      position: absolute;
      bottom: 90px; left: 50%; transform: translateX(-50%);
      width: calc(100% - 24px);
      max-width: 640px;
      background: rgba(0,0,0,0.92);
      border: 2px solid #eab308;
      border-radius: 8px;
      padding: 12px;
      z-index: 20;
    }
    .dialogue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .dialogue-name { color: #facc15; font-weight: bold; }
    .dialogue-counter { color: #6b7280; font-size: 0.75rem; }
    .dialogue-text { color: white; font-size: 0.9rem; margin-bottom: 12px; }
    .scene-text {
      color: #fde047;
      font-size: 0.9rem;
      font-style: italic;
      margin-bottom: 12px;
      font-family: Georgia, serif;
    }
    .btn {
      width: 100%;
      background: #ca8a04;
      color: white;
      font-weight: bold;
      padding: 8px 16px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn:hover { background: #eab308; }
    .btn:active { background: #a16207; }
    .quest-text {
      position: absolute;
      top: 34px; left: 50%; transform: translateX(-50%);
      color: #fde047;
      font-size: 0.8rem;
      text-shadow: 0 1px 3px #000;
      pointer-events: none;
      white-space: nowrap;
      z-index: 10;
    }
    .controls {
      position: absolute;
      bottom: 14px; left: 50%; transform: translateX(-50%);
      display: flex;
      gap: 32px;
      align-items: center;
      z-index: 20;
    }
    .dpad {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 4px;
    }
    .dpad-btn {
      width: 56px;
      height: 56px;
      background: rgba(31,41,55,0.85);
      border: 2px solid #4b5563;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      color: #d1d5db;
      cursor: pointer;
    }
    .dpad-btn:active { background: #374151; border-color: #eab308; }
    .talk-btn {
      width: 72px;
      height: 72px;
      background: #ca8a04;
      border: 4px solid #facc15;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 0.85rem;
      cursor: pointer;
    }
    .talk-btn:active { background: #eab308; }
    .phase-indicator {
      position: absolute;
      bottom: 14px; left: 50%; transform: translateX(-50%);
      color: #f87171;
      font-size: 0.85rem;
      font-weight: bold;
      text-transform: uppercase;
      text-shadow: 0 1px 3px #000;
      z-index: 10;
    }
    .help-text {
      position: absolute;
      bottom: 4px; right: 8px;
      color: #4b5563;
      font-size: 0.65rem;
      z-index: 10;
    }
    /* ── Cutscene overlay ────────────────────────────────── */
    .cutscene-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      z-index: 20;
      pointer-events: none;
    }
    .cutscene-header {
      position: absolute;
      top: 0; left: 0; right: 0;
      text-align: center;
      padding: 18px 12px 10px;
      pointer-events: none;
    }
    .cutscene-day {
      color: #d4a017;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 3px;
      font-family: Georgia, serif;
      text-shadow: 0 1px 6px #000;
    }
    .cutscene-counter {
      position: absolute;
      top: 10px; right: 14px;
      color: #6b7280;
      font-size: 0.7rem;
    }
    .cutscene-box {
      margin: 0 auto 28px;
      width: calc(100% - 24px);
      max-width: 680px;
      background: rgba(0,0,0,0.88);
      border: 2px solid #d4a017;
      border-radius: 10px;
      padding: 18px 18px 14px;
      pointer-events: auto;
    }
    .cutscene-ref {
      color: #8b7340;
      font-size: 0.7rem;
      margin-bottom: 10px;
      font-family: Georgia, serif;
      letter-spacing: 1px;
    }
    .cutscene-verse {
      color: #f5e6c8;
      font-size: 0.88rem;
      line-height: 1.55;
      font-family: Georgia, serif;
      margin-bottom: 8px;
    }
    .cutscene-verse:last-of-type { margin-bottom: 14px; }
    .cutscene-btn {
      width: 100%;
      background: linear-gradient(180deg, #b8860b, #8b6914);
      color: #fff;
      font-weight: bold;
      padding: 10px 16px;
      border-radius: 5px;
      border: 1px solid #d4a017;
      cursor: pointer;
      font-size: 0.9rem;
      letter-spacing: 1px;
      transition: background 0.2s;
    }
    .cutscene-btn:hover { background: linear-gradient(180deg, #d4a017, #b8860b); }
    .cutscene-btn:active { background: #8b6914; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;

    const TILE_SIZE = 64;
    const SCALE = 2;            // sprite / decoration scale (= TILE_SIZE / 32)
    const MAP_WIDTH = 80;
    const MAP_HEIGHT = 60;
    // Viewport dims are computed dynamically each frame from the canvas client size
    // so they always match the actual displayed resolution (handles fullscreen, resize, etc.)
    const getVP = (canvas) => ({
      w: Math.ceil((canvas.clientWidth  || window.innerWidth)  / TILE_SIZE) + 2,
      h: Math.ceil((canvas.clientHeight || window.innerHeight) / TILE_SIZE) + 2,
    });

    const GARDEN_BOUNDS = { minX: 10, maxX: 70, minY: 10, maxY: 48 };
    const TREE_OF_KNOWLEDGE = { x: 20, y: 22 };
    const SKIN_COLOR = '#5D4037';

    const TILES = {
      GRASS: 0, WATER: 1, TREE: 2, FLOWER: 3, PATH: 4,
      TREE_OF_LIFE: 5, TREE_OF_KNOWLEDGE: 6, ROCK: 7, BUSH: 8, GOLDEN_GATE: 9,
    };

    const COLORS = {
      grass: '#5a8f3d', grassDark: '#4a7f2d', water: '#3d7aaf', waterLight: '#5d9acf',
      tree: '#2d5a1d', treeTrunk: '#8b4513', flower: '#ff69b4', flowerYellow: '#ffd700',
      path: '#c9a86c', rock: '#808080', bush: '#3d6f2d', treeOfLife: '#ffd700',
      treeOfKnowledge: '#8b0000', sky: '#87ceeb',
    };

    // Seeded PRNG (mulberry32) – gives a consistent map on every load
    const seededRandom = (seed) => {
      let s = seed | 0;
      return () => { s = (s + 0x6D2B79F5) | 0; let t = Math.imul(s ^ (s >>> 15), 1 | s); t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t; return ((t ^ (t >>> 14)) >>> 0) / 4294967296; };
    };

    const generateMap = () => {
      const rng = seededRandom(12345);
      const TOL = { x: 56, y: 20 };   // Tree of Life
      const TOK = TREE_OF_KNOWLEDGE;   // { x: 20, y: 22 }
      const map = [];
      for (let y = 0; y < MAP_HEIGHT; y++) {
        const row = [];
        for (let x = 0; x < MAP_WIDTH; x++) {
          // River
          if (y >= 46 && y <= 50) row.push(TILES.WATER);
          // Garden paths: vertical spine x=30, horizontal corridor y=26
          else if ((x === 30 && y >= 10 && y <= 45) || (y === 26 && x >= 14 && x <= 66)) row.push(TILES.PATH);
          // Dense tree border around the whole map
          else if (x < 6 || x > MAP_WIDTH - 7 || y < 6 || y > MAP_HEIGHT - 7) row.push(rng() > 0.25 ? TILES.TREE : TILES.GRASS);
          else {
            const rand = rng();
            if (rand < 0.04) row.push(TILES.TREE);
            else if (rand < 0.07) row.push(TILES.FLOWER);
            else if (rand < 0.09) row.push(TILES.BUSH);
            else if (rand < 0.10) row.push(TILES.ROCK);
            else row.push(TILES.GRASS);
          }
        }
        map.push(row);
      }
      map[TOL.y][TOL.x] = TILES.TREE_OF_LIFE;
      map[TOK.y][TOK.x] = TILES.TREE_OF_KNOWLEDGE;
      // ── Golden Gate + Eastern Path ────────────────────────────────────────
      const GATE = { x: 63, y: 26 };
      // Carve a visible PATH corridor east of the gate all the way to the map edge
      for (let x = GATE.x + 1; x < MAP_WIDTH; x++) map[GATE.y][x] = TILES.PATH;
      // Flanking tree walls N and S of the gate — player cannot walk around it
      for (let dx = -1; dx <= 3; dx++) {
        const nx = GATE.x + dx;
        if (map[GATE.y - 1] && map[GATE.y - 1][nx] !== undefined) map[GATE.y - 1][nx] = TILES.TREE;
        if (map[GATE.y + 1] && map[GATE.y + 1][nx] !== undefined) map[GATE.y + 1][nx] = TILES.TREE;
      }
      map[GATE.y][GATE.x] = TILES.GOLDEN_GATE;
      // ─────────────────────────────────────────────────────────────────────
      // Clear a walkable ring around each special tree
      for (let dy = -3; dy <= 3; dy++) {
        for (let dx = -3; dx <= 3; dx++) {
          if (map[TOL.y + dy] && map[TOL.y + dy][TOL.x + dx] !== undefined && map[TOL.y + dy][TOL.x + dx] !== TILES.TREE_OF_LIFE) map[TOL.y + dy][TOL.x + dx] = TILES.GRASS;
          if (map[TOK.y + dy] && map[TOK.y + dy][TOK.x + dx] !== undefined && map[TOK.y + dy][TOK.x + dx] !== TILES.TREE_OF_KNOWLEDGE) map[TOK.y + dy][TOK.x + dx] = TILES.GRASS;
        }
      }
      return map;
    };

    const createNPCs = () => [
      {
        id: 'adam', name: "A'dam", x: 38, y: 30, prevX: 38, prevY: 30, color: SKIN_COLOR, hairColor: '#1a1a1a',
        thoughts: ["YAHUAH formed me from the dust...", "I am to dress and keep this garden.", "She is bone of my bones..."],
        dialogue: ["Shalom, traveler. I am A'dam.", "YAHUAH ELOHIYM formed me of the dust of the ground.", "He breathed into my nostrils the breath of life.", "I became a living nephesh.", "YAHUAH put me in the Garden of Eden to dress it and keep it.", "Of every tree I may freely eat...", "But of the Ets HaDa'at Tov v'Ra, I shall not eat.", "For in the day I eat thereof, I shall surely die."],
        currentDialogue: 0, currentThought: 0, thoughtTimer: 0, behavior: 'wander', homeX: 38, homeY: 30, targetX: null, targetY: null, moveTimer: 0, walkFrame: 0, isMoving: false, direction: 'down', hasSpoken: false, holdingFruit: false, isEating: false, hasGlory: true, hasClothes: false, clothesBlink: 0,
      },
      {
        id: 'chavvah', name: 'Chavvah', x: 42, y: 30, prevX: 42, prevY: 30, color: SKIN_COLOR, hairColor: '#1a1a1a', isEve: true,
        thoughts: ["The garden is so beautiful...", "That tree... the fruit looks good...", "The nachash says we won't die..."],
        dialogue: ["I am Chavvah, the mother of all living.", "YAHUAH ELOHIYM caused a deep sleep upon A'dam.", "He took one of his ribs and made me.", "We may eat of the fruit of the trees of the garden.", "But of the tree in the midst of the garden...", "ELOHIYM has said, Ye shall not eat of it.", "Neither shall ye touch it, lest ye die.", "But the nachash says our eyes will be opened..."],
        currentDialogue: 0, currentThought: 0, thoughtTimer: 0, behavior: 'wander', homeX: 42, homeY: 30, targetX: null, targetY: null, moveTimer: 0, walkFrame: 0, isMoving: false, direction: 'down', hasSpoken: false, holdingFruit: false, isEating: false, hasGlory: true, hasClothes: false, clothesBlink: 0,
      },
      {
        id: 'nachash', name: 'Nachash', x: 20, y: 24, prevX: 20, prevY: 24, color: '#228b22', isSerpent: true,
        thoughts: ["Yea, hath ELOHIYM said...?", "Ye shall not surely die...", "Your eyes shall be opened..."],
        dialogue: ["Yea, hath ELOHIYM said...", "Ye shall not eat of every tree of the garden?", "Ye shall not surely die.", "For ELOHIYM knows that in the day ye eat thereof...", "Your eyes shall be opened.", "And ye shall be as elohiym...", "Knowing good and evil.", "Is the fruit not pleasant to the eyes?"],
        currentDialogue: 0, currentThought: 0, thoughtTimer: 0, behavior: 'circle_tree', circleAngle: 0, targetX: null, targetY: null, moveTimer: 0, walkFrame: 0, isMoving: false, direction: 'down', hasSpoken: false,
      },
      {
        id: 'malak', name: 'Malak', x: 61, y: 26, prevX: 61, prevY: 26, color: SKIN_COLOR, hairColor: '#1a1a1a', isAngel: true,
        thoughts: ["None may pass the Sha'ar Zahav!", "The flaming sword turns every way...", "I guard the eastern gate of Eden."],
        dialogue: ["Shalom. I am a malak of YAHUAH.", "I stand guard at the Sha'ar Zahav - the Golden Gate.", "None may pass through this gate without YAHUAH's word.", "Beyond lies the path out of the garden.", "YAHUAH set cherubim to guard the way.", "Turn back, child. The garden is your dwelling."],
        currentDialogue: 0, currentThought: 0, thoughtTimer: 0, behavior: 'patrol', patrolPoints: [{x: 61, y: 26}, {x: 59, y: 26}, {x: 61, y: 26}], patrolIndex: 0, targetX: null, targetY: null, moveTimer: 0, walkFrame: 0, isMoving: false, direction: 'right', hasSpoken: false,
      }
    ];

    const PHASES = {
      CUTSCENE: 'cutscene',
      EXPLORE: 'explore', SCENE_START: 'scene_start', CHAVVAH_WALKS_TO_TREE: 'chavvah_walks',
      CHAVVAH_TAKES_FRUIT: 'chavvah_takes', CHAVVAH_EATS: 'chavvah_eats', CHAVVAH_GLORY_FADES: 'chavvah_glory_fades',
      CHAVVAH_WALKS_TO_ADAM: 'chavvah_to_adam', ADAM_EATS: 'adam_eats', ADAM_GLORY_FADES: 'adam_glory_fades',
      EYES_OPENED: 'eyes_opened', COMPLETE: 'complete'
    };

    // ── Creation cutscene slides (Cepher – Bere'shiyth 1-2) ──────────
    const CUTSCENE_SLIDES = [
      // 0 – The Void  (1:1-2)
      { day: null, ref: "Bere'shiyth 1:1-2", scene: 'void',
        lines: [
          "IN the beginning ELOHIYM created \u05D0\u05EA the heavens and \u05D0\u05EA the earth.",
          "And the earth was without form, and void; and darkness was upon the face of the deep. And the RUACH ELOHIYM moved upon the face of the waters.",
        ]},
      // 1 – Day 1: Light  (1:3-5)
      { day: 'The First Day', ref: "Bere'shiyth 1:3-5", scene: 'light',
        lines: [
          "And ELOHIYM said, Let there be light: and there was light.",
          "And ELOHIYM saw \u05D0\u05EA the light, that it was good: and ELOHIYM divided the light from the darkness.",
          "And ELOHIYM called the light Day, and the darkness he called Night. And the evening and the morning were the first day.",
        ]},
      // 2 – Day 2: Firmament  (1:6-8)
      { day: 'The Second Day', ref: "Bere'shiyth 1:6-8", scene: 'firmament',
        lines: [
          "And ELOHIYM said, Let there be a firmament in the midst of the waters, and let it divide the waters from the waters.",
          "And ELOHIYM made \u05D0\u05EA the firmament, and divided the waters which were under the firmament from the waters which were above the firmament: and it was so.",
          "And ELOHIYM called the firmament Heaven. And the evening and the morning were the second day.",
        ]},
      // 3 – Day 3: Land & vegetation  (1:9-13)
      { day: 'The Third Day', ref: "Bere'shiyth 1:9-13", scene: 'land',
        lines: [
          "And ELOHIYM said, Let the waters under the heaven be gathered together unto one place, and let the dry land appear: and it was so.",
          "And ELOHIYM said, Let the earth bring forth grass, the herb yielding seed, and the fruit tree yielding fruit after his kind, whose seed is in itself, upon the earth: and it was so.",
          "And the evening and the morning were the third day.",
        ]},
      // 4 – Day 4: Luminaries  (1:14-19)
      { day: 'The Fourth Day', ref: "Bere'shiyth 1:14-19", scene: 'luminaries',
        lines: [
          "And ELOHIYM said, Let there be lights in the firmament of the heaven to divide the day from the night; and let them be for signs, and for appointed times, and for days, and years.",
          "And ELOHIYM made \u05D0\u05EA two great lights; the greater light to rule the day, and the lesser light to rule the night: he made the stars also.",
          "And the evening and the morning were the fourth day.",
        ]},
      // 5 – Day 5: Sea & sky creatures  (1:20-23)
      { day: 'The Fifth Day', ref: "Bere'shiyth 1:20-23", scene: 'creatures_sea',
        lines: [
          "And ELOHIYM said, Let the waters bring forth abundantly the moving creature that has life, and fowl that may fly above the earth in the open firmament of heaven.",
          "And ELOHIYM created \u05D0\u05EA great whales, and \u05D0\u05EA every living creature that moves, which the waters brought forth abundantly, after their kind, and \u05D0\u05EA every winged fowl after his kind: and ELOHIYM saw that it was good.",
          "And the evening and the morning were the fifth day.",
        ]},
      // 6 – Day 6 part 1: Land animals  (1:24-25)
      { day: 'The Sixth Day', ref: "Bere'shiyth 1:24-25", scene: 'creatures_land',
        lines: [
          "And ELOHIYM said, Let the earth bring forth the living creature after his kind, cattle, and creeping thing, and beast of the earth after his kind: and it was so.",
          "And ELOHIYM made \u05D0\u05EA the beast of the earth after his kind, and \u05D0\u05EA cattle after their kind, and \u05D0\u05EA every thing that creeps upon the earth after his kind: and ELOHIYM saw that it was good.",
        ]},
      // 7 – Day 6 part 2: Man  (1:26-28)
      { day: 'The Sixth Day', ref: "Bere'shiyth 1:26-28", scene: 'man',
        lines: [
          "And ELOHIYM said, Let us make A\u2019dam in our image, after our likeness: and let them have dominion over the fish of the sea, and over the fowl of the air, and over the cattle, and over all the earth.",
          "So ELOHIYM created \u05D0\u05EA A\u2019dam in his own image, in the image of ELOHIYM he created him; male and female he created them.",
          "And ELOHIYM blessed them, and ELOHIYM said unto them, Be fruitful, and multiply, and replenish the earth, and subdue it.",
        ]},
      // 8 – Day 6 part 3: Provision  (1:29-31)
      { day: 'The Sixth Day', ref: "Bere'shiyth 1:29-31", scene: 'provision',
        lines: [
          "And ELOHIYM said, Behold, I have given you \u05D0\u05EA every herb bearing seed, which is upon the face of all the earth, and \u05D0\u05EA every tree, in the which is the fruit of a tree yielding seed; to you it shall be for food.",
          "And ELOHIYM saw \u05D0\u05EA everything that he had made, and, behold, it was very good. And the evening and the morning were the sixth day.",
        ]},
      // 9 – Day 7: Rest  (2:1-3)
      { day: 'The Seventh Day', ref: "Bere'shiyth 2:1-3", scene: 'rest',
        lines: [
          "Thus the heavens and the earth were finished, and all the host of them.",
          "And on the seventh day ELOHIYM ended his work which he had made; and he rested on the seventh day from all his work which he had made.",
          "And ELOHIYM blessed \u05D0\u05EA the seventh day, and sanctified it: because that in it he had rested from all his work which ELOHIYM created and made.",
        ]},
      // 10 – Garden of Eden  (2:7-9)
      { day: null, ref: "Bere'shiyth 2:7-9", scene: 'garden',
        lines: [
          "And YAHUAH ELOHIYM formed \u05D0\u05EA the man of the dust of the ground, and breathed into his nostrils the breath of life; and the man became a living soul.",
          "And YAHUAH ELOHIYM planted a garden eastward in Eden; and there he put \u05D0\u05EA the man whom he had formed.",
          "And out of the ground made YAHUAH ELOHIYM to grow every tree that is pleasant to the sight, and good for food; the tree of life also in the midst of the garden, and the tree of knowledge of good and evil.",
        ]},
    ];

    const GenesisGame = () => {
      const canvasRef = useRef(null);
      const [map] = useState(generateMap);
      const [player, setPlayer] = useState({ x: 35, y: 30, prevX: 35, prevY: 30, direction: 'down', walkFrame: 0, isMoving: false });
      const [npcs, setNpcs] = useState(createNPCs);
      const [camera, setCamera] = useState({ x: 0, y: 0 });
      const [showDialogue, setShowDialogue] = useState(null);
      const [sceneText, setSceneText] = useState("Bere'shiyth - In the beginning ELOHIYM created the heavens and the earth...");
      const [showSceneText, setShowSceneText] = useState(false);
      const [gameTime, setGameTime] = useState(0);
      const [gamePhase, setGamePhase] = useState(PHASES.CUTSCENE);
      const [cutsceneSlide, setCutsceneSlide] = useState(0);
      const keysPressed = useRef({});
      const [touchDirection, setTouchDirection] = useState(null);
      // Refs to avoid stale closures in game loop
      const touchDirRef = useRef(null);
      const showDialogueRef = useRef(null);
      const gamePhaseRef = useRef(PHASES.CUTSCENE);
      const npcsRef = useRef(null);

      // Keep refs in sync with state for the game loop
      useEffect(() => { touchDirRef.current = touchDirection; }, [touchDirection]);
      useEffect(() => { showDialogueRef.current = showDialogue; }, [showDialogue]);
      useEffect(() => { gamePhaseRef.current = gamePhase; }, [gamePhase]);
      useEffect(() => { npcsRef.current = npcs; }, [npcs]);

      const checkSceneTrigger = useCallback(() => {
        const adam = npcs.find(n => n.id === 'adam');
        const chavvah = npcs.find(n => n.id === 'chavvah');
        const nachash = npcs.find(n => n.id === 'nachash');
        return adam?.hasSpoken && chavvah?.hasSpoken && nachash?.hasSpoken;
      }, [npcs]);

      const canNPCMoveTo = useCallback((x, y) => {
        if (x < GARDEN_BOUNDS.minX || x > GARDEN_BOUNDS.maxX || y < GARDEN_BOUNDS.minY || y > GARDEN_BOUNDS.maxY) return false;
        if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return false;
        const tile = map[Math.floor(y)][Math.floor(x)];
        return tile === TILES.GRASS || tile === TILES.PATH;
      }, [map]);

      const canMoveTo = useCallback((x, y, currentNpcs) => {
        if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return false;
        const tile = map[Math.floor(y)][Math.floor(x)];
        if (tile !== TILES.GRASS && tile !== TILES.PATH) return false;
        // Block walking through NPCs
        if (currentNpcs) {
          for (const npc of currentNpcs) {
            if (Math.abs(x - npc.x) < 0.8 && Math.abs(y - npc.y) < 0.8) return false;
          }
        }
        return true;
      }, [map]);

      useEffect(() => {
        if (gamePhase === PHASES.CUTSCENE) return; // no camera during cutscene
        const vp = getVP(canvasRef.current || { clientWidth: window.innerWidth, clientHeight: window.innerHeight });
        if (gamePhase === PHASES.EXPLORE || gamePhase === PHASES.COMPLETE) {
          setCamera({
            x: Math.max(0, Math.min(player.x - vp.w / 2, MAP_WIDTH - vp.w)),
            y: Math.max(0, Math.min(player.y - vp.h / 2, MAP_HEIGHT - vp.h))
          });
        } else {
          const chavvah = npcs.find(n => n.id === 'chavvah');
          if (chavvah) {
            setCamera({
              x: Math.max(0, Math.min(chavvah.x - vp.w / 2, MAP_WIDTH - vp.w)),
              y: Math.max(0, Math.min(chavvah.y - vp.h / 2, MAP_HEIGHT - vp.h))
            });
          }
        }
      }, [player, npcs, gamePhase]);

      const advanceDialogue = useCallback(() => {
        if (!showDialogue) return;
        const currentNpc = npcs.find(n => n.id === showDialogue.id);
        if (currentNpc) {
          const nextDialogue = showDialogue.currentDialogue + 1;
          if (nextDialogue >= currentNpc.dialogue.length) {
            setShowDialogue(null);
            setNpcs(prev => prev.map(npc => npc.id === currentNpc.id ? { ...npc, hasSpoken: true, currentDialogue: 0 } : npc));
          } else {
            setShowDialogue({ ...showDialogue, currentDialogue: nextDialogue });
          }
        }
      }, [showDialogue, npcs]);

      const handleInteraction = useCallback(() => {
        if (showDialogue) { advanceDialogue(); return; }
        if (showSceneText) { setShowSceneText(false); return; }
        if (gamePhase === PHASES.EXPLORE) {
          const nearbyNpc = npcs.find(npc => Math.abs(npc.x - player.x) < 1.5 && Math.abs(npc.y - player.y) < 1.5);
          if (nearbyNpc) setShowDialogue({ ...nearbyNpc, currentDialogue: 0 });
        }
      }, [showDialogue, showSceneText, gamePhase, npcs, player, advanceDialogue]);

      const advanceScene = useCallback(() => {
        setShowSceneText(false);
        switch (gamePhase) {
          case PHASES.SCENE_START:
            setGamePhase(PHASES.CHAVVAH_WALKS_TO_TREE);
            setSceneText("And when the woman saw that the tree was good for food, and pleasant to the eyes...");
            setShowSceneText(true);
            break;
          case PHASES.CHAVVAH_TAKES_FRUIT:
            setNpcs(prev => prev.map(npc => npc.id === 'chavvah' ? { ...npc, holdingFruit: true } : npc));
            setGamePhase(PHASES.CHAVVAH_EATS);
            setSceneText("She took of the fruit thereof...");
            setShowSceneText(true);
            break;
          case PHASES.CHAVVAH_EATS:
            setNpcs(prev => prev.map(npc => npc.id === 'chavvah' ? { ...npc, isEating: true } : npc));
            setTimeout(() => {
              setNpcs(prev => prev.map(npc => npc.id === 'chavvah' ? { ...npc, isEating: false } : npc));
              setGamePhase(PHASES.CHAVVAH_GLORY_FADES);
              setSceneText("And did eat... and the glory of YAHUAH departed from her...");
              setShowSceneText(true);
              setTimeout(() => {
                setNpcs(prev => prev.map(npc => npc.id === 'chavvah' ? { ...npc, hasGlory: false, clothesBlink: 4 } : npc));
              }, 500);
            }, 1500);
            break;
          case PHASES.CHAVVAH_GLORY_FADES:
            setGamePhase(PHASES.CHAVVAH_WALKS_TO_ADAM);
            setSceneText("And gave also unto her husband with her...");
            setShowSceneText(true);
            break;
          case PHASES.ADAM_EATS:
            setNpcs(prev => prev.map(npc => npc.id === 'adam' ? { ...npc, holdingFruit: true, isEating: true } : npc));
            setTimeout(() => {
              setNpcs(prev => prev.map(npc => npc.id === 'adam' ? { ...npc, isEating: false } : npc));
              setGamePhase(PHASES.ADAM_GLORY_FADES);
              setSceneText("And he did eat... and the glory departed from him also...");
              setShowSceneText(true);
              setTimeout(() => {
                setNpcs(prev => prev.map(npc => npc.id === 'adam' ? { ...npc, hasGlory: false, clothesBlink: 4 } : npc));
              }, 500);
            }, 1500);
            break;
          case PHASES.ADAM_GLORY_FADES:
            setGamePhase(PHASES.EYES_OPENED);
            setSceneText("And the eyes of them both were opened, and they knew that they were naked...");
            setShowSceneText(true);
            break;
          case PHASES.EYES_OPENED:
            setGamePhase(PHASES.COMPLETE);
            setSceneText("And they sewed fig leaves together, and made themselves aprons...");
            setShowSceneText(true);
            break;
        }
      }, [gamePhase]);

      const advanceCutscene = useCallback(() => {
        const next = cutsceneSlide + 1;
        if (next >= CUTSCENE_SLIDES.length) {
          // Cutscene over – transition to explore
          setGamePhase(PHASES.EXPLORE);
          setSceneText("Explore the Garden of Eden. Speak to A\u2019dam, Chavvah, and the Nachash...");
          setShowSceneText(true);
        } else {
          setCutsceneSlide(next);
        }
      }, [cutsceneSlide]);

      useEffect(() => {
        const handleKeyDown = (e) => {
          keysPressed.current[e.key.toLowerCase()] = true;
          if (e.key === ' ' || e.key === 'Enter') {
            e.preventDefault();
            if (gamePhase === PHASES.CUTSCENE) advanceCutscene();
            else if (showSceneText && gamePhase !== PHASES.EXPLORE) advanceScene();
            else handleInteraction();
          }
        };
        const handleKeyUp = (e) => { keysPressed.current[e.key.toLowerCase()] = false; };
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        return () => { window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); };
      }, [handleInteraction, advanceScene, advanceCutscene, showSceneText, gamePhase]);

      const handleTouchStart = (direction) => setTouchDirection(direction);
      const handleTouchEnd = () => setTouchDirection(null);

      useEffect(() => {
        const FRAME_MS = 1000 / 30;  // target 30 FPS
        let lastTime = 0;
        let rafId;
        const gameLoop = (timestamp) => {
          rafId = requestAnimationFrame(gameLoop);
          if (timestamp - lastTime < FRAME_MS) return;
          lastTime = timestamp;

          const phase = gamePhaseRef.current;
          const dlg   = showDialogueRef.current;
          const touch = touchDirRef.current;
          const currentNpcs = npcsRef.current;

          setGameTime(prev => prev + 1);

          // Check scene trigger using ref (avoids stale closure)
          if (phase === PHASES.EXPLORE && currentNpcs) {
            const adam = currentNpcs.find(n => n.id === 'adam');
            const chavvah = currentNpcs.find(n => n.id === 'chavvah');
            const nachash = currentNpcs.find(n => n.id === 'nachash');
            if (adam?.hasSpoken && chavvah?.hasSpoken && nachash?.hasSpoken) {
              setGamePhase(PHASES.SCENE_START);
              setSceneText("The nachash beguiled Chavvah... she looked upon the forbidden tree...");
              setShowSceneText(true);
            }
          }

          if (!dlg && phase === PHASES.EXPLORE) {
            setPlayer(prev => {
              let newX = prev.x, newY = prev.y, newDir = prev.direction;
              const speed = 0.15;
              const up = keysPressed.current['w'] || keysPressed.current['arrowup'] || touch === 'up';
              const down = keysPressed.current['s'] || keysPressed.current['arrowdown'] || touch === 'down';
              const left = keysPressed.current['a'] || keysPressed.current['arrowleft'] || touch === 'left';
              const right = keysPressed.current['d'] || keysPressed.current['arrowright'] || touch === 'right';
              if (up) { newY -= speed; newDir = 'up'; }
              if (down) { newY += speed; newDir = 'down'; }
              if (left) { newX -= speed; newDir = 'left'; }
              if (right) { newX += speed; newDir = 'right'; }
              let finalX = prev.x, finalY = prev.y;
              // Use npcsRef for fresh NPC positions (fixes stale closure bug)
              const liveNpcs = npcsRef.current;
              if (canMoveTo(newX, newY, liveNpcs)) { finalX = newX; finalY = newY; }
              else if (canMoveTo(newX, prev.y, liveNpcs)) { finalX = newX; }
              else if (canMoveTo(prev.x, newY, liveNpcs)) { finalY = newY; }
              const isMoving = finalX !== prev.x || finalY !== prev.y;
              const walkFrame = isMoving ? (prev.walkFrame + 0.3) % 4 : 0;
              return { x: finalX, y: finalY, prevX: prev.x, prevY: prev.y, direction: newDir, walkFrame, isMoving };
            });
          }
          if (!dlg && phase !== PHASES.CUTSCENE) {
            setNpcs(prev => prev.map(npc => {
              let newNpc = { ...npc, moveTimer: npc.moveTimer + 1, thoughtTimer: npc.thoughtTimer + 1 };
              if (npc.clothesBlink > 0) {
                newNpc.clothesBlink = npc.clothesBlink - 0.1;
                if (newNpc.clothesBlink <= 0) { newNpc.clothesBlink = 0; newNpc.hasClothes = true; }
              }
              if (newNpc.thoughtTimer > 150) { newNpc.currentThought = (npc.currentThought + 1) % npc.thoughts.length; newNpc.thoughtTimer = 0; }
              if (npc.id === 'chavvah') {
                if (phase === PHASES.CHAVVAH_WALKS_TO_TREE) {
                  newNpc.behavior = 'scene'; newNpc.targetX = TREE_OF_KNOWLEDGE.x + 1; newNpc.targetY = TREE_OF_KNOWLEDGE.y + 1;
                  if (Math.abs(npc.x - (TREE_OF_KNOWLEDGE.x + 1)) < 0.3 && Math.abs(npc.y - (TREE_OF_KNOWLEDGE.y + 1)) < 0.3) {
                    setGamePhase(PHASES.CHAVVAH_TAKES_FRUIT);
                    setSceneText("And a tree to be desired to make one wise...");
                    setShowSceneText(true);
                  }
                } else if (phase === PHASES.CHAVVAH_WALKS_TO_ADAM) {
                  const adam = prev.find(n => n.id === 'adam');
                  if (adam) {
                    newNpc.targetX = adam.x - 1; newNpc.targetY = adam.y;
                    if (Math.abs(npc.x - (adam.x - 1)) < 0.5 && Math.abs(npc.y - adam.y) < 0.5) {
                      setGamePhase(PHASES.ADAM_EATS);
                      setSceneText("And gave also unto her husband with her; and he did eat...");
                      setShowSceneText(true);
                    }
                  }
                }
              }
              if (npc.id === 'adam' && phase !== PHASES.EXPLORE) { newNpc.behavior = 'scene'; newNpc.targetX = null; newNpc.targetY = null; newNpc.isMoving = false; }
              if (npc.behavior === 'circle_tree') {
                newNpc.circleAngle = (npc.circleAngle || 0) + 0.02;
                const radius = 2.5;
                newNpc.targetX = TREE_OF_KNOWLEDGE.x + Math.cos(newNpc.circleAngle) * radius;
                newNpc.targetY = TREE_OF_KNOWLEDGE.y + Math.sin(newNpc.circleAngle) * radius;
              }
              if (npc.behavior === 'wander' && phase === PHASES.EXPLORE && newNpc.moveTimer > 90) {
                if (!npc.targetX || (Math.abs(npc.x - npc.targetX) < 0.5 && Math.abs(npc.y - npc.targetY) < 0.5)) {
                  let attempts = 0, validTarget = false;
                  while (!validTarget && attempts < 10) {
                    const newTargetX = npc.homeX + (Math.random() - 0.5) * 8;
                    const newTargetY = npc.homeY + (Math.random() - 0.5) * 6;
                    if (canNPCMoveTo(newTargetX, newTargetY)) { newNpc.targetX = newTargetX; newNpc.targetY = newTargetY; validTarget = true; }
                    attempts++;
                  }
                  if (!validTarget) { newNpc.targetX = npc.homeX; newNpc.targetY = npc.homeY; }
                  newNpc.moveTimer = 0;
                }
              }
              if (npc.behavior === 'patrol' && npc.patrolPoints) {
                const target = npc.patrolPoints[npc.patrolIndex];
                if (Math.abs(npc.x - target.x) < 0.3 && Math.abs(npc.y - target.y) < 0.3) newNpc.patrolIndex = (npc.patrolIndex + 1) % npc.patrolPoints.length;
                newNpc.targetX = npc.patrolPoints[newNpc.patrolIndex].x;
                newNpc.targetY = npc.patrolPoints[newNpc.patrolIndex].y;
              }
              newNpc.prevX = npc.x; newNpc.prevY = npc.y;
              if (newNpc.targetX !== null && newNpc.targetY !== null) {
                const dx = newNpc.targetX - npc.x, dy = newNpc.targetY - npc.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0.1) {
                  const speed = (npc.id === 'chavvah' && phase !== PHASES.EXPLORE) ? 0.04 : 0.03;
                  const moveX = npc.x + (dx / dist) * speed, moveY = npc.y + (dy / dist) * speed;
                  if (canNPCMoveTo(moveX, moveY) || npc.behavior === 'scene' || npc.behavior === 'circle_tree') {
                    newNpc.x = moveX; newNpc.y = moveY; newNpc.isMoving = true; newNpc.walkFrame = (npc.walkFrame + 0.25) % 4;
                    newNpc.direction = Math.abs(dx) >= Math.abs(dy) ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'down' : 'up');
                  } else { newNpc.targetX = npc.homeX || npc.x; newNpc.targetY = npc.homeY || npc.y; newNpc.isMoving = false; newNpc.walkFrame = 0; }
                } else { newNpc.isMoving = false; newNpc.walkFrame = 0; }
              } else { newNpc.isMoving = false; newNpc.walkFrame = 0; }
              return newNpc;
            }));
          }
        };
        rafId = requestAnimationFrame(gameLoop);
        return () => cancelAnimationFrame(rafId);
      }, [canMoveTo, canNPCMoveTo]);

      const drawSpeechBubble = (ctx, x, y, text, isSerpent = false) => {
        const FONT = 'bold 14px sans-serif';
        const maxWidth = 240, padding = 11, lineHeight = 20;
        ctx.font = FONT;
        const words = text.split(' ');
        const lines = [];
        let currentLine = '';
        words.forEach(word => {
          const testLine = currentLine + (currentLine ? ' ' : '') + word;
          if (ctx.measureText(testLine).width > maxWidth - padding * 2) { if (currentLine) lines.push(currentLine); currentLine = word; }
          else currentLine = testLine;
        });
        if (currentLine) lines.push(currentLine);
        const bubbleWidth = Math.min(maxWidth, Math.max(...lines.map(l => ctx.measureText(l).width)) + padding * 2);
        const bubbleHeight = lines.length * lineHeight + padding * 2;
        const bubbleX = x - bubbleWidth / 2, bubbleY = y - bubbleHeight - 26;
        ctx.fillStyle = isSerpent ? 'rgba(20, 40, 20, 0.96)' : 'rgba(255, 255, 255, 0.96)';
        ctx.strokeStyle = isSerpent ? '#5a9c5a' : '#444';
        ctx.lineWidth = 2;
        const radius = 10;
        ctx.beginPath();
        ctx.moveTo(bubbleX + radius, bubbleY);
        ctx.lineTo(bubbleX + bubbleWidth - radius, bubbleY);
        ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + radius);
        ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - radius);
        ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - radius, bubbleY + bubbleHeight);
        ctx.lineTo(bubbleX + radius, bubbleY + bubbleHeight);
        ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - radius);
        ctx.lineTo(bubbleX, bubbleY + radius);
        ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + radius, bubbleY);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = isSerpent ? 'rgba(20, 40, 20, 0.96)' : 'rgba(255, 255, 255, 0.96)';
        ctx.beginPath(); ctx.arc(x - 5, bubbleY + bubbleHeight + 6, 5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.arc(x - 1, bubbleY + bubbleHeight + 14, 3, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = isSerpent ? '#aaffaa' : '#111';
        ctx.font = FONT;
        lines.forEach((line, i) => { ctx.fillText(line, bubbleX + padding, bubbleY + padding + lineHeight * (i + 0.85)); });
      };

      // Pokemon Generation III TDSM-style sprite renderer.
      // Chibi proportions: big head (~13 px, ~50 % of height), short body (7 px),
      // short chunky legs (7 px + 2 px shoe).  Dark pixel outline on every part.
      // All coordinates are anchored to cx (tile centre) so the sprite is always
      // perfectly symmetric and nothing ever detaches.
      //
      // Layout (by = screenY + bob):
      //   HEAD  : by+ 0 … by+13   (hair fills top half, face bottom half)
      //   BODY  : by+13 … by+20
      //   ARMS  : by+13 … by+20   (2 px wide, outside body)
      //   LEGS  : by+20 … by+27
      //   SHOES : by+26 … by+28
      const drawCharacterSprite = (ctx, screenX, screenY, opts) => {
        const {
          walkFrame = 0, isMoving = false, direction = 'down',
          hairColor = '#1a1a1a', bodyColor = '#4169e1', skinColor = SKIN_COLOR,
          isEve = false, showClothes = false,
          holdingFruit = false, isEating = false, hasGlory = false, gameTime = 0,
        } = opts;

        const frame = Math.floor(walkFrame) % 4;
        const bob   = isMoving && frame % 2 === 1 ? 1 : 0;
        const cx    = screenX + 16;   // horizontal centre – never drifts
        const by    = screenY + bob;  // head top

        // r(dx,dy,w,h,color) – fill a rect relative to cx / by
        const r = (dx, dy, w, h, c) => { ctx.fillStyle = c; ctx.fillRect(cx + dx, by + dy, w, h); };

        const DK   = '#0d0700';                              // dark pixel outline
        const SH   = '#17100a';                              // shoe colour
        const bClr = showClothes ? '#8b7355' : bodyColor;   // shirt / torso

        // ── GLORY AURA ────────────────────────────────────────────
        if (hasGlory) {
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur  = 12 + Math.sin(gameTime * 0.15) * 4;
          ctx.fillStyle   = 'rgba(255,215,0,0.22)';
          ctx.beginPath();
          ctx.ellipse(cx, by + 14, 13, 16, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }

        const isSide = direction === 'left' || direction === 'right';

        // ── LEGS  (tops ALWAYS at by+20 = body bottom; never detach) ─────
        if (isSide) {
          // Side profile: wider leg implies two overlapping legs in profile.
          // Two shoes swing in opposite phase to mimic a two-footed stride.
          const dir = direction === 'right' ? 1 : -1;
          const fStep = !isMoving ? 0 : frame === 1 ?  2*dir : frame === 3 ? -2*dir : 0;
          const bStep = !isMoving ? 0 : frame === 1 ? -2*dir : frame === 3 ?  2*dir : 0;
          r(-3, 20, 6, 6, bClr);               // wider leg (two legs overlapping in profile)
          r(-4 + bStep, 26, 7, 2, bClr);       // back shoe (body colour = depth cue)
          r(-4 + fStep, 26, 7, 2, SH);         // front shoe swings forward / back
        } else if (!isMoving) {
          r(-5, 20, 4, 6, bClr);  r(-6, 26, 6, 2, SH);  // left
          r( 1, 20, 4, 6, bClr);  r( 0, 26, 6, 2, SH);  // right
        } else {
          // Front / back view: alternate which leg strides
          const fwdX = frame < 2 ? -5 :  1;
          const bckX = frame < 2 ?  1 : -5;
          r(bckX, 20, 4, 4, bClr);  r(bckX - 1, 24, 5, 2, SH);  // back (shorter)
          r(fwdX, 20, 4, 6, bClr);  r(fwdX - 1, 26, 6, 2, SH);  // forward (full)
        }

        // ── BODY  (by+13 … by+20) ─────────────────────────────────
        r(-6, 12, 12, 9, DK);     // outline
        r(-5, 13, 10, 7, bClr);   // fill

        // ── ARMS ──────────────────────────────────────────────────
        if (isSide) {
          // Side profile: single arm centered on body, swings with walk
          const aSwg = isMoving ? (frame < 2 ? 2 : -2) : 0;
          r(-2, 13 + aSwg, 4, 8, DK);          // outline
          r(-1, 14 + aSwg, 2, 6, skinColor);    // skin fill
        } else {
          // Front / back: two arms on opposite sides, swing in counter-phase
          const armSwg = isMoving ? (frame < 2 ? 2 : -2) : 0;
          r(-8, 13 + armSwg, 3, 7, DK);  r(-8, 14 + armSwg, 2, 5, skinColor);  // left
          r( 5, 13 - armSwg, 3, 7, DK);  r( 5, 14 - armSwg, 2, 5, skinColor);  // right
        }

        // ── HEAD  (by+0 … by+13) ──────────────────────────────────
        // Gen III chibi: head ≈ 50 % of total height.
        // Dark outline box → base skin → hair overlay → eyes on top.

        r(-7, 0, 14, 14, DK);          // dark outline (1 px border)
        r(-6, 1, 12, 12, skinColor);   // base skin fill

        // HAIR – direction specific
        if (direction === 'up') {
          r(-6, 1, 12, 12, hairColor); // back-of-head: all hair
        } else if (direction === 'left') {
          r(-6, 1, 12, 7, hairColor);  // top hair band (generous, Gen III style)
          r( 3, 1,  3, 12, hairColor); // right-side hair visible in left profile
        } else if (direction === 'right') {
          r(-6, 1, 12, 7, hairColor);
          r(-6, 1,  3, 12, hairColor); // left-side hair visible in right profile
        } else {
          r(-6, 1, 12, 7, hairColor);  // facing down: thick top band (covers ~60 % of head)
        }

        // Chavvah / Eve: long flowing side strands (outside head outline)
        if (isEve && direction !== 'up') {
          r(-9, 5, 3, 10, hairColor);
          r( 6, 5, 3, 10, hairColor);
        }

        // EYES – two when facing down, one when facing sideways, none when facing up
        if (direction !== 'up') {
          if (direction !== 'left') {   // right eye (visible facing down or right)
            r( 1, 9, 3, 3, '#f0f0f0');
            r( 2, 10, 2, 2, DK);
          }
          if (direction !== 'right') {  // left eye (visible facing down or left)
            r(-4, 9, 3, 3, '#f0f0f0');
            r(-4, 10, 2, 2, DK);
          }
        }

        // Eating indicator
        if (isEating) { r(-2, 11, 4, 2, '#8b0000'); }

        // Held fruit (held to the right of body)
        if (holdingFruit && !isEating) {
          ctx.fillStyle = '#cc0000';
          ctx.beginPath(); ctx.arc(cx + 10, by + 17, 4, 0, Math.PI * 2); ctx.fill();
          r(8, 13, 2, 4, '#654321'); // stem
        }
      };

      // ── Cutscene canvas renderer ────────────────────────────────────
      const drawCutscene = (ctx, W, H, slide, t) => {
        const scene = CUTSCENE_SLIDES[slide]?.scene || 'void';
        const cx = W / 2, cy = H / 2;

        // helper: pseudo-random from seed (deterministic sparkle / star positions)
        const pr = (i) => ((Math.sin(i * 127.1 + i * 311.7) * 43758.5453) % 1 + 1) % 1;

        switch (scene) {

          // ── 0: The Void ─────────────────────────────────────────────
          case 'void': {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, W, H);
            // subtle deep-water particles drifting
            for (let i = 0; i < 60; i++) {
              const px = (pr(i) * W + t * 0.15 * (pr(i + 99) - 0.5)) % W;
              const py = (pr(i + 50) * H + t * 0.1 * pr(i + 200)) % H;
              const r = 1 + pr(i + 30) * 2.5;
              const a = 0.04 + 0.06 * Math.sin(t * 0.04 + i);
              ctx.fillStyle = `rgba(40,60,120,${a})`;
              ctx.beginPath(); ctx.arc(px, py, r, 0, Math.PI * 2); ctx.fill();
            }
            // moving shimmer across the deep
            const shimX = (t * 0.8) % (W + 200) - 100;
            const grad = ctx.createLinearGradient(shimX - 80, 0, shimX + 80, 0);
            grad.addColorStop(0, 'rgba(60,80,160,0)');
            grad.addColorStop(0.5, 'rgba(80,120,200,0.08)');
            grad.addColorStop(1, 'rgba(60,80,160,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);
            break;
          }

          // ── 1: Light ────────────────────────────────────────────────
          case 'light': {
            // left = darkness, right = light, dividing line oscillates
            const split = cx + Math.sin(t * 0.03) * 30;
            ctx.fillStyle = '#020208';
            ctx.fillRect(0, 0, split, H);
            const lg = ctx.createRadialGradient(split + W * 0.3, cy, 0, split + W * 0.3, cy, W * 0.6);
            lg.addColorStop(0, '#fffbe6');
            lg.addColorStop(0.4, '#ffe066');
            lg.addColorStop(1, '#332800');
            ctx.fillStyle = lg;
            ctx.fillRect(split, 0, W - split, H);
            // rays emanating from the divide
            ctx.save();
            ctx.globalAlpha = 0.15 + 0.05 * Math.sin(t * 0.08);
            for (let i = 0; i < 12; i++) {
              const angle = (i / 12) * Math.PI - Math.PI / 2 + Math.sin(t * 0.02 + i) * 0.1;
              ctx.strokeStyle = '#ffd700';
              ctx.lineWidth = 2 + pr(i) * 3;
              ctx.beginPath();
              ctx.moveTo(split, cy);
              ctx.lineTo(split + Math.cos(angle) * W * 0.7, cy + Math.sin(angle) * H * 0.8);
              ctx.stroke();
            }
            ctx.restore();
            break;
          }

          // ── 2: Firmament ────────────────────────────────────────────
          case 'firmament': {
            // waters above (top third)
            const wg1 = ctx.createLinearGradient(0, 0, 0, H * 0.3);
            wg1.addColorStop(0, '#1a2a5c');
            wg1.addColorStop(1, '#2d5aaf');
            ctx.fillStyle = wg1;
            ctx.fillRect(0, 0, W, H * 0.3);
            // ripples above
            ctx.strokeStyle = 'rgba(120,180,255,0.2)';
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 6; i++) {
              const ry = H * 0.05 + i * H * 0.04;
              ctx.beginPath();
              for (let x = 0; x < W; x += 4) {
                const yy = ry + Math.sin(x * 0.02 + t * 0.05 + i * 2) * 4;
                x === 0 ? ctx.moveTo(x, yy) : ctx.lineTo(x, yy);
              }
              ctx.stroke();
            }
            // firmament band (middle)
            const fg = ctx.createLinearGradient(0, H * 0.3, 0, H * 0.7);
            fg.addColorStop(0, '#5ba3d9');
            fg.addColorStop(0.5, '#87ceeb');
            fg.addColorStop(1, '#5ba3d9');
            ctx.fillStyle = fg;
            ctx.fillRect(0, H * 0.3, W, H * 0.4);
            // label
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.font = `bold ${Math.max(14, W * 0.03)}px Georgia, serif`;
            ctx.textAlign = 'center';
            ctx.fillText('SHAMAYIM', cx, cy + 5);
            ctx.textAlign = 'left';
            // waters below (bottom third)
            const wg2 = ctx.createLinearGradient(0, H * 0.7, 0, H);
            wg2.addColorStop(0, '#2d5aaf');
            wg2.addColorStop(1, '#0a1a3c');
            ctx.fillStyle = wg2;
            ctx.fillRect(0, H * 0.7, W, H * 0.3);
            for (let i = 0; i < 6; i++) {
              const ry = H * 0.75 + i * H * 0.04;
              ctx.beginPath();
              for (let x = 0; x < W; x += 4) {
                const yy = ry + Math.sin(x * 0.015 + t * 0.04 + i * 3) * 5;
                x === 0 ? ctx.moveTo(x, yy) : ctx.lineTo(x, yy);
              }
              ctx.strokeStyle = 'rgba(80,140,220,0.18)';
              ctx.stroke();
            }
            break;
          }

          // ── 3: Land & Vegetation ────────────────────────────────────
          case 'land': {
            // sky
            const skyG = ctx.createLinearGradient(0, 0, 0, H * 0.5);
            skyG.addColorStop(0, '#87ceeb');
            skyG.addColorStop(1, '#b8e4f8');
            ctx.fillStyle = skyG;
            ctx.fillRect(0, 0, W, H * 0.5);
            // sea on left
            ctx.fillStyle = '#3d7aaf';
            ctx.fillRect(0, H * 0.5, W * 0.35, H * 0.5);
            for (let i = 0; i < 8; i++) {
              ctx.strokeStyle = 'rgba(100,180,255,0.2)';
              ctx.beginPath();
              for (let x = 0; x < W * 0.35; x += 3) {
                const yy = H * 0.55 + i * 20 + Math.sin(x * 0.03 + t * 0.06 + i) * 3;
                x === 0 ? ctx.moveTo(x, yy) : ctx.lineTo(x, yy);
              }
              ctx.stroke();
            }
            // land mass rising from right
            const landG = ctx.createLinearGradient(0, H * 0.45, 0, H);
            landG.addColorStop(0, '#8b7355');
            landG.addColorStop(0.3, '#6b5530');
            landG.addColorStop(1, '#4a3820');
            ctx.fillStyle = landG;
            ctx.beginPath();
            ctx.moveTo(W * 0.3, H);
            ctx.quadraticCurveTo(W * 0.35, H * 0.5, W * 0.5, H * 0.42);
            ctx.quadraticCurveTo(W * 0.7, H * 0.38, W, H * 0.45);
            ctx.lineTo(W, H);
            ctx.fill();
            // grass on top of land
            ctx.fillStyle = '#4e7c2b';
            ctx.beginPath();
            ctx.moveTo(W * 0.3, H);
            ctx.quadraticCurveTo(W * 0.35, H * 0.49, W * 0.5, H * 0.41);
            ctx.quadraticCurveTo(W * 0.7, H * 0.37, W, H * 0.44);
            ctx.lineTo(W, H * 0.45); ctx.quadraticCurveTo(W * 0.7, H * 0.38, W * 0.5, H * 0.42);
            ctx.quadraticCurveTo(W * 0.35, H * 0.5, W * 0.3, H);
            ctx.fill();
            // helper: get Y on the grass-top curve at a given X
            // The grass curve is two quadratic segments:
            //   seg1: (W*0.3,H) ctrl(W*0.35,H*0.49) to(W*0.5,H*0.41)
            //   seg2: (W*0.5,H*0.41) ctrl(W*0.7,H*0.37) to(W,H*0.44)
            const landY = (px) => {
              if (px <= W * 0.5) {
                const tt = Math.max(0, Math.min(1, (px - W * 0.3) / (W * 0.2)));
                const p0y = H, c0y = H * 0.49, p1y = H * 0.41;
                return (1-tt)*(1-tt)*p0y + 2*(1-tt)*tt*c0y + tt*tt*p1y;
              } else {
                const tt = Math.max(0, Math.min(1, (px - W * 0.5) / (W * 0.5)));
                const p0y = H * 0.41, c0y = H * 0.37, p1y = H * 0.44;
                return (1-tt)*(1-tt)*p0y + 2*(1-tt)*tt*c0y + tt*tt*p1y;
              }
            };
            // little trees sprouting on the land surface (emoji)
            const day3Trees = ['🌳', '🌲', '🌳', '🌴', '🌲', '🌳', '🌲'];
            for (let i = 0; i < 7; i++) {
              const tx = W * 0.42 + i * W * 0.08;
              const ty = landY(tx);          // base sits on the curve
              const sz = 18 + pr(i + 10) * 14;
              ctx.font = `${sz}px serif`;
              ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
              ctx.fillText(day3Trees[i], tx, ty + sz * 0.15);
            }
            ctx.textAlign = 'left';
            break;
          }

          // ── 4: Luminaries (sun, moon, stars) ────────────────────────
          case 'luminaries': {
            // gradient sky: dark blue left (night), warm right (day)
            const skyG = ctx.createLinearGradient(0, 0, W, 0);
            skyG.addColorStop(0, '#0a0a2e');
            skyG.addColorStop(0.45, '#1a1a4e');
            skyG.addColorStop(0.55, '#cc6600');
            skyG.addColorStop(1, '#ffd080');
            ctx.fillStyle = skyG;
            ctx.fillRect(0, 0, W, H);
            // stars on the dark side
            for (let i = 0; i < 80; i++) {
              const sx = pr(i) * W * 0.5;
              const sy = pr(i + 50) * H;
              const sr = 0.5 + pr(i + 100) * 1.8;
              const sa = 0.3 + 0.5 * Math.sin(t * 0.1 + i * 7);
              ctx.fillStyle = `rgba(255,255,220,${sa})`;
              ctx.beginPath(); ctx.arc(sx, sy, sr, 0, Math.PI * 2); ctx.fill();
            }
            // moon (left)
            ctx.fillStyle = '#e8e8d0';
            ctx.shadowColor = '#e8e8ff'; ctx.shadowBlur = 20;
            ctx.beginPath(); ctx.arc(W * 0.2, H * 0.3, 35, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            // moon dark side (crescent)
            ctx.fillStyle = '#0a0a2e';
            ctx.beginPath(); ctx.arc(W * 0.2 + 12, H * 0.3 - 2, 30, 0, Math.PI * 2); ctx.fill();
            // sun (right)
            ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 40 + Math.sin(t * 0.08) * 10;
            ctx.fillStyle = '#ffe066';
            ctx.beginPath(); ctx.arc(W * 0.78, H * 0.35, 45, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            // sun rays
            ctx.save(); ctx.globalAlpha = 0.2;
            for (let i = 0; i < 16; i++) {
              const a = (i / 16) * Math.PI * 2 + t * 0.01;
              ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(W * 0.78 + Math.cos(a) * 50, H * 0.35 + Math.sin(a) * 50);
              ctx.lineTo(W * 0.78 + Math.cos(a) * 90, H * 0.35 + Math.sin(a) * 90);
              ctx.stroke();
            }
            ctx.restore();
            break;
          }

          // ── 5: Sea creatures & birds ────────────────────────────────
          case 'creatures_sea': {
            // ocean background
            const oG = ctx.createLinearGradient(0, 0, 0, H);
            oG.addColorStop(0, '#87ceeb');
            oG.addColorStop(0.35, '#5daacf');
            oG.addColorStop(0.4, '#3d7aaf');
            oG.addColorStop(1, '#0a2a4c');
            ctx.fillStyle = oG;
            ctx.fillRect(0, 0, W, H);
            // water surface line
            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x < W; x += 3) {
              const yy = H * 0.38 + Math.sin(x * 0.02 + t * 0.06) * 4;
              x === 0 ? ctx.moveTo(x, yy) : ctx.lineTo(x, yy);
            }
            ctx.stroke();
            // light rays under water
            ctx.save();
            ctx.globalAlpha = 0.04;
            for (let i = 0; i < 6; i++) {
              const rx = W * 0.15 + i * W * 0.14;
              ctx.fillStyle = '#88ccff';
              ctx.beginPath();
              ctx.moveTo(rx - 8, H * 0.38);
              ctx.lineTo(rx - 30, H);
              ctx.lineTo(rx + 30, H);
              ctx.lineTo(rx + 8, H * 0.38);
              ctx.fill();
            }
            ctx.restore();
            // bubbles
            for (let i = 0; i < 12; i++) {
              const bx = (pr(i + 150) * W + Math.sin(t * 0.03 + i) * 15);
              const by = H - ((t * 0.4 + pr(i + 160) * H) % (H * 0.55));
              ctx.strokeStyle = `rgba(180,220,255,${0.15 + 0.1 * Math.sin(t * 0.06 + i)})`;
              ctx.lineWidth = 1;
              ctx.beginPath(); ctx.arc(bx, by + H * 0.4, 2 + pr(i + 170) * 4, 0, Math.PI * 2); ctx.stroke();
            }
            // emoji fish swimming at various depths
            const fishEmoji = ['\uD83D\uDC1F', '\uD83D\uDC20', '\uD83D\uDC21', '\uD83D\uDC1F', '\uD83D\uDC20', '\uD83D\uDC21', '\uD83D\uDC1F', '\uD83D\uDC20'];
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            for (let i = 0; i < fishEmoji.length; i++) {
              const speed = 0.4 + pr(i + 5) * 0.6;
              const fx = ((pr(i) * W + t * speed) % (W + 60)) - 30;
              const fy = H * 0.46 + pr(i + 20) * H * 0.3;
              const sz = 18 + pr(i + 30) * 16;
              const bob = Math.sin(t * 0.08 + i * 2.5) * 5;
              ctx.save();
              ctx.translate(fx, fy + bob);
              // flip fish facing right (moving right)
              ctx.scale(-1, 1);
              ctx.font = `${sz}px serif`;
              ctx.fillText(fishEmoji[i], 0, 0);
              ctx.restore();
            }
            // hand-drawn animated whale
            const wSpeed = 0.25;
            const wx = ((t * wSpeed) % (W + 300)) - 150;
            const wBob = Math.sin(t * 0.03) * 8;
            const wY = H * 0.70 + wBob;
            const wLen = Math.max(60, W * 0.1);  // whale body length
            const tailWag = Math.sin(t * 0.12) * 10; // tail wag animation
            const bodyWave = Math.sin(t * 0.06) * 3; // gentle body undulation
            ctx.save();
            ctx.translate(wx, wY);
            // whale body (elongated oval)
            ctx.fillStyle = '#2a4a6a';
            ctx.beginPath();
            ctx.moveTo(-wLen * 0.5, 0);
            ctx.bezierCurveTo(-wLen * 0.5, -wLen * 0.35,
                              wLen * 0.3, -wLen * 0.38 + bodyWave,
                              wLen * 0.55, -wLen * 0.05 + bodyWave);
            ctx.bezierCurveTo(wLen * 0.3, wLen * 0.3 + bodyWave,
                              -wLen * 0.3, wLen * 0.3,
                              -wLen * 0.5, 0);
            ctx.fill();
            // lighter belly
            ctx.fillStyle = '#5a8aaa';
            ctx.beginPath();
            ctx.moveTo(-wLen * 0.4, wLen * 0.05);
            ctx.bezierCurveTo(-wLen * 0.2, wLen * 0.22,
                              wLen * 0.15, wLen * 0.22 + bodyWave,
                              wLen * 0.4, wLen * 0.02 + bodyWave);
            ctx.bezierCurveTo(wLen * 0.15, wLen * 0.15 + bodyWave,
                              -wLen * 0.2, wLen * 0.15,
                              -wLen * 0.4, wLen * 0.05);
            ctx.fill();
            // tail fluke (animated)
            ctx.fillStyle = '#2a4a6a';
            ctx.beginPath();
            ctx.moveTo(wLen * 0.5, -wLen * 0.05 + bodyWave);
            ctx.quadraticCurveTo(wLen * 0.65, -wLen * 0.05 + bodyWave,
                                 wLen * 0.8, -wLen * 0.25 + tailWag);
            ctx.quadraticCurveTo(wLen * 0.65, -wLen * 0.02 + bodyWave,
                                 wLen * 0.65, wLen * 0.02 + bodyWave);
            ctx.quadraticCurveTo(wLen * 0.65, wLen * 0.05 + bodyWave,
                                 wLen * 0.8, wLen * 0.2 - tailWag);
            ctx.quadraticCurveTo(wLen * 0.65, wLen * 0.05 + bodyWave,
                                 wLen * 0.5, wLen * 0.02 + bodyWave);
            ctx.fill();
            // eye
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(-wLen * 0.28, -wLen * 0.08, wLen * 0.05, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.arc(-wLen * 0.27, -wLen * 0.08, wLen * 0.025, 0, Math.PI * 2); ctx.fill();
            // mouth line
            ctx.strokeStyle = '#1a3a5a'; ctx.lineWidth = 1.5; ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-wLen * 0.48, wLen * 0.02);
            ctx.quadraticCurveTo(-wLen * 0.3, wLen * 0.08, -wLen * 0.15, wLen * 0.04);
            ctx.stroke();
            // dorsal fin
            ctx.fillStyle = '#2a4a6a';
            ctx.beginPath();
            ctx.moveTo(wLen * 0.05, -wLen * 0.28 + bodyWave);
            ctx.quadraticCurveTo(wLen * 0.15, -wLen * 0.45 + bodyWave, wLen * 0.25, -wLen * 0.26 + bodyWave);
            ctx.lineTo(wLen * 0.05, -wLen * 0.28 + bodyWave);
            ctx.fill();
            ctx.restore();
            // spout – periodic water spray above the whale's head
            const spoutCycle = (t * 0.02) % (Math.PI * 2);
            if (spoutCycle < Math.PI * 0.6) {
              const spoutAlpha = Math.sin(spoutCycle / 0.6);
              const spoutX = wx - wLen * 0.3;
              const spoutBaseY = wY - wLen * 0.35;
              ctx.save();
              ctx.globalAlpha = spoutAlpha * 0.7;
              ctx.strokeStyle = '#b0d8f0'; ctx.lineWidth = 2; ctx.lineCap = 'round';
              const spH = 25 * spoutAlpha;
              ctx.beginPath();
              ctx.moveTo(spoutX, spoutBaseY);
              ctx.quadraticCurveTo(spoutX - 8, spoutBaseY - spH * 0.6, spoutX - 12, spoutBaseY - spH);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(spoutX, spoutBaseY);
              ctx.quadraticCurveTo(spoutX + 8, spoutBaseY - spH * 0.6, spoutX + 12, spoutBaseY - spH);
              ctx.stroke();
              // droplets at the top
              ctx.fillStyle = '#b0d8f0';
              for (let d = 0; d < 5; d++) {
                const dx = spoutX + (d - 2) * 5;
                const dy = spoutBaseY - spH - 2 - Math.abs(d - 2) * 2;
                ctx.beginPath(); ctx.arc(dx, dy, 1.5, 0, Math.PI * 2); ctx.fill();
              }
              ctx.restore();
            }
            // birds in the sky – simple flapping V-lines
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2; ctx.lineCap = 'round';
            for (let i = 0; i < 8; i++) {
              const bx = ((pr(i + 60) * W + t * (0.5 + pr(i + 70) * 0.8)) % (W + 60)) - 30;
              const byy = H * 0.06 + pr(i + 80) * H * 0.26;
              const wingSpan = 8 + pr(i + 90) * 6;
              const flap = Math.sin(t * 0.15 + i * 3) * wingSpan * 0.5;
              ctx.beginPath();
              ctx.moveTo(bx - wingSpan, byy - flap);
              ctx.quadraticCurveTo(bx - wingSpan * 0.3, byy + flap * 0.3, bx, byy);
              ctx.quadraticCurveTo(bx + wingSpan * 0.3, byy + flap * 0.3, bx + wingSpan, byy - flap);
              ctx.stroke();
            }
            ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
            break;
          }

          // ── 6: Land creatures ───────────────────────────────────────
          case 'creatures_land': {
            // sky + grass
            const sG = ctx.createLinearGradient(0, 0, 0, H * 0.55);
            sG.addColorStop(0, '#87ceeb');
            sG.addColorStop(1, '#b8e4f8');
            ctx.fillStyle = sG;
            ctx.fillRect(0, 0, W, H * 0.55);
            ctx.fillStyle = '#4e7c2b';
            ctx.fillRect(0, H * 0.55, W, H * 0.45);
            ctx.fillStyle = '#3d6a20';
            ctx.fillRect(0, H * 0.55, W, 4);
            // grass tufts
            ctx.strokeStyle = '#5a8a30';
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 20; i++) {
              const gx = pr(i + 200) * W;
              const gy = H * 0.56 + pr(i + 210) * H * 0.06;
              for (let b = -1; b <= 1; b++) {
                ctx.beginPath();
                ctx.moveTo(gx + b * 3, gy);
                ctx.quadraticCurveTo(gx + b * 5 + Math.sin(t * 0.04 + i) * 2, gy - 8, gx + b * 4, gy - 12);
                ctx.stroke();
              }
            }
            // emoji animals walking across the land
            const landAnimals = [
              { emoji: '\uD83D\uDC2E', ox: 0.10, oy: 0.63, sz: 32, spd: 0.20 },  // cow
              { emoji: '\uD83E\uDD81', ox: 0.55, oy: 0.60, sz: 36, spd: 0.35 },  // lion
              { emoji: '\uD83D\uDC11', ox: 0.30, oy: 0.70, sz: 26, spd: 0.15 },  // sheep
              { emoji: '\uD83E\uDD8C', ox: 0.72, oy: 0.66, sz: 30, spd: 0.25 },  // deer
              { emoji: '\uD83D\uDC0E', ox: 0.45, oy: 0.62, sz: 34, spd: 0.40 },  // horse
              { emoji: '\uD83D\uDC18', ox: 0.85, oy: 0.64, sz: 38, spd: 0.12 },  // elephant
              { emoji: '\uD83D\uDC07', ox: 0.20, oy: 0.76, sz: 22, spd: 0.50 },  // rabbit
              { emoji: '\uD83E\uDD92', ox: 0.65, oy: 0.56, sz: 40, spd: 0.18 },  // giraffe
              { emoji: '\uD83D\uDC0D', ox: 0.40, oy: 0.80, sz: 20, spd: 0.10 },  // snake (creeping)
              { emoji: '\uD83E\uDD8E', ox: 0.78, oy: 0.82, sz: 18, spd: 0.08 },  // lizard (creeping)
            ];
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            landAnimals.forEach((an, i) => {
              const ax = ((an.ox * W + t * an.spd) % (W + 80)) - 40;
              const ay = an.oy * H;
              const bob = Math.sin(t * 0.1 + i * 2.1) * 3;
              ctx.save();
              ctx.translate(ax, ay + bob);
              ctx.scale(-1, 1); // face right
              ctx.font = `${an.sz}px serif`;
              ctx.fillText(an.emoji, 0, 0);
              ctx.restore();
            });
            ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
            break;
          }

          // ── 7: Man created ──────────────────────────────────────────
          case 'man': {
            // golden radiant background
            const rg = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(W, H) * 0.7);
            rg.addColorStop(0, '#fffbe0');
            rg.addColorStop(0.3, '#ffd700');
            rg.addColorStop(0.7, '#996600');
            rg.addColorStop(1, '#1a0a00');
            ctx.fillStyle = rg;
            ctx.fillRect(0, 0, W, H);
            // dust particles rising from below
            for (let i = 0; i < 40; i++) {
              const dx = cx + (pr(i) - 0.5) * W * 0.5;
              const dy = H - ((t * 0.6 + pr(i + 20) * 200) % (H * 0.8));
              const ds = 1 + pr(i + 40) * 3;
              ctx.fillStyle = `rgba(180,140,80,${0.15 + 0.1 * Math.sin(t * 0.06 + i)})`;
              ctx.beginPath(); ctx.arc(dx, dy, ds, 0, Math.PI * 2); ctx.fill();
            }
            // silhouette of man with glory aura
            const figY = cy + H * 0.05;
            // glory aura
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 30 + Math.sin(t * 0.08) * 10;
            ctx.fillStyle = 'rgba(255,215,0,0.2)';
            ctx.beginPath(); ctx.ellipse(cx, figY - 10, 40, 55, 0, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            // figure
            ctx.fillStyle = '#3a2510';
            // head
            ctx.beginPath(); ctx.arc(cx, figY - 40, 14, 0, Math.PI * 2); ctx.fill();
            // body
            ctx.fillRect(cx - 8, figY - 26, 16, 24);
            // arms raised
            ctx.save(); ctx.lineWidth = 6; ctx.strokeStyle = '#3a2510'; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(cx - 8, figY - 20); ctx.lineTo(cx - 28, figY - 38); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx + 8, figY - 20); ctx.lineTo(cx + 28, figY - 38); ctx.stroke();
            ctx.restore();
            // legs
            ctx.fillRect(cx - 7, figY - 2, 6, 20);
            ctx.fillRect(cx + 1, figY - 2, 6, 20);
            break;
          }

          // ── 8: Provision ────────────────────────────────────────────
          case 'provision': {
            // lush garden scene
            const sG = ctx.createLinearGradient(0, 0, 0, H * 0.45);
            sG.addColorStop(0, '#6eb5e0');
            sG.addColorStop(1, '#a8daf0');
            ctx.fillStyle = sG;
            ctx.fillRect(0, 0, W, H * 0.45);
            // rolling green hills
            ctx.fillStyle = '#5a9a3a';
            ctx.beginPath();
            ctx.moveTo(0, H * 0.5);
            for (let x = 0; x <= W; x += 20) {
              ctx.lineTo(x, H * 0.44 + Math.sin(x * 0.008 + 1) * H * 0.04);
            }
            ctx.lineTo(W, H); ctx.lineTo(0, H);
            ctx.fill();
            ctx.fillStyle = '#4a8a2a';
            ctx.beginPath();
            ctx.moveTo(0, H * 0.55);
            for (let x = 0; x <= W; x += 20) {
              ctx.lineTo(x, H * 0.52 + Math.sin(x * 0.006 + 3) * H * 0.03);
            }
            ctx.lineTo(W, H); ctx.lineTo(0, H);
            ctx.fill();
            // helper: sample the front hill curve at any X
            const hillY = (px) => H * 0.44 + Math.sin(px * 0.008 + 1) * H * 0.04;
            // fruit trees – emoji trees sitting on the hill curve
            const fruitTrees = ['🌳', '🌴', '🌲', '🌳', '🌴', '🌳'];
            for (let i = 0; i < 6; i++) {
              const tx = W * 0.1 + i * W * 0.15;
              const ty = hillY(tx);            // tree base on the curve
              ctx.font = '36px serif';
              ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
              ctx.fillText(fruitTrees[i], tx, ty + 5);
            }
            ctx.textAlign = 'left';
            // herbs / grain at bottom
            ctx.strokeStyle = '#3a6a10';
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 30; i++) {
              const gx = pr(i + 90) * W;
              const gy = H * 0.75 + pr(i + 91) * H * 0.2;
              const gh = 8 + pr(i + 92) * 14;
              ctx.beginPath();
              ctx.moveTo(gx, gy);
              ctx.quadraticCurveTo(gx + Math.sin(t * 0.05 + i) * 4, gy - gh * 0.6, gx + Math.sin(t * 0.05 + i) * 3, gy - gh);
              ctx.stroke();
            }
            break;
          }

          // ── 9: Seventh Day – Rest ───────────────────────────────────
          case 'rest': {
            // peaceful golden twilight
            const rG = ctx.createRadialGradient(cx, cy * 0.7, 0, cx, cy * 0.7, Math.max(W, H) * 0.8);
            rG.addColorStop(0, '#fff8e0');
            rG.addColorStop(0.3, '#ffe4a0');
            rG.addColorStop(0.6, '#cc8844');
            rG.addColorStop(1, '#221100');
            ctx.fillStyle = rG;
            ctx.fillRect(0, 0, W, H);
            // soft pulsing light
            ctx.save();
            const pulse = 0.08 + 0.04 * Math.sin(t * 0.04);
            ctx.globalAlpha = pulse;
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(cx, cy * 0.7, 120 + Math.sin(t * 0.03) * 20, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
            // gentle drifting motes
            for (let i = 0; i < 25; i++) {
              const mx = cx + Math.sin(t * 0.01 + i * 1.3) * W * 0.4;
              const my = cy + Math.cos(t * 0.008 + i * 0.9) * H * 0.35;
              ctx.fillStyle = `rgba(255,240,180,${0.1 + 0.08 * Math.sin(t * 0.05 + i)})`;
              ctx.beginPath(); ctx.arc(mx, my, 2 + pr(i) * 3, 0, Math.PI * 2); ctx.fill();
            }
            break;
          }

          // ── 10: Garden of Eden ──────────────────────────────────────
          case 'garden': {
            // rich sky
            const sG = ctx.createLinearGradient(0, 0, 0, H * 0.4);
            sG.addColorStop(0, '#5a9ae0');
            sG.addColorStop(1, '#87ceeb');
            ctx.fillStyle = sG;
            ctx.fillRect(0, 0, W, H * 0.4);
            // lush ground
            ctx.fillStyle = '#3a7a22';
            ctx.fillRect(0, H * 0.4, W, H * 0.6);
            // garden path down the middle
            ctx.fillStyle = '#c9a86c';
            ctx.fillRect(cx - 20, H * 0.4, 40, H * 0.6);
            // Tree of Life (right, golden)
            const tolX = cx + W * 0.25;
            ctx.fillStyle = '#654321';
            ctx.fillRect(tolX - 6, H * 0.2, 12, H * 0.25);
            ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 25 + Math.sin(t * 0.1) * 8;
            ctx.fillStyle = '#ffd700';
            ctx.beginPath(); ctx.arc(tolX, H * 0.15, 35, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(255,255,200,0.4)';
            ctx.beginPath(); ctx.arc(tolX, H * 0.15, 25, 0, Math.PI * 2); ctx.fill();
            // Tree of Knowledge (left, dark with red fruit)
            const tokX = cx - W * 0.25;
            ctx.fillStyle = '#4a3520';
            ctx.fillRect(tokX - 6, H * 0.2, 12, H * 0.25);
            ctx.fillStyle = '#1a3a1a';
            ctx.beginPath(); ctx.arc(tokX, H * 0.15, 35, 0, Math.PI * 2); ctx.fill();
            // red fruits
            for (let i = 0; i < 6; i++) {
              const a = (i / 6) * Math.PI * 2 + 0.3;
              ctx.fillStyle = '#cc0000';
              ctx.beginPath(); ctx.arc(tokX + Math.cos(a) * 20, H * 0.15 + Math.sin(a) * 18, 5, 0, Math.PI * 2); ctx.fill();
            }
            // decorative emoji trees lining the garden
            const gardenTrees = ['🌳', '🌲', '🌳', '🌴', '🌲', '🌳', '🌲', '🌳', '🌴', '🌳'];
            for (let i = 0; i < 10; i++) {
              const tx = i * (W / 10) + W * 0.05;
              if (Math.abs(tx - cx) < 40 || Math.abs(tx - tolX) < 50 || Math.abs(tx - tokX) < 50) continue;
              ctx.font = '28px serif';
              ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
              ctx.fillText(gardenTrees[i], tx, H * 0.44);
            }
            ctx.textAlign = 'left';
            // flowers
            for (let i = 0; i < 15; i++) {
              const fx = pr(i + 120) * W;
              const fy = H * 0.5 + pr(i + 130) * H * 0.35;
              if (Math.abs(fx - cx) < 25) continue;
              ctx.fillStyle = i % 3 === 0 ? '#ff69b4' : i % 3 === 1 ? '#ffd700' : '#ff4444';
              ctx.beginPath(); ctx.arc(fx, fy, 3 + pr(i + 140) * 2, 0, Math.PI * 2); ctx.fill();
            }
            // golden gate in the distance (top right)
            ctx.fillStyle = '#daa520';
            ctx.fillRect(W * 0.88, H * 0.3, 5, H * 0.15);
            ctx.fillRect(W * 0.93, H * 0.3, 5, H * 0.15);
            ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(W * 0.905, H * 0.31, 13, Math.PI, 0); ctx.stroke();
            break;
          }

          default: {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, W, H);
          }
        }
      };

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        // Account for device pixel ratio so canvas text and graphics are
        // crisp on Retina / high-DPI screens.  All coordinates below stay
        // in CSS pixels; only the bitmap is larger.
        const dpr = window.devicePixelRatio || 1;
        const W = canvas.clientWidth  || window.innerWidth;
        const H = canvas.clientHeight || window.innerHeight;
        if (canvas.width  !== Math.round(W * dpr)) canvas.width  = Math.round(W * dpr);
        if (canvas.height !== Math.round(H * dpr)) canvas.height = Math.round(H * dpr);
        const vp = { w: Math.ceil(W / TILE_SIZE) + 2, h: Math.ceil(H / TILE_SIZE) + 2 };
        const ctx = canvas.getContext('2d');
        // Reset transform then apply DPR scale so every draw call uses CSS px.
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        // ── CUTSCENE rendering ──────────────────────────────────────────
        if (gamePhase === PHASES.CUTSCENE) {
          drawCutscene(ctx, W, H, cutsceneSlide, gameTime);
          return; // don't draw the map during the cutscene
        }

        ctx.fillStyle = COLORS.sky;
        ctx.fillRect(0, 0, W, H);

        // ── PASS 1: Ground layer (flat tiles) ─────────────────────────────
        const tallObjects = [];
        for (let y = 0; y < vp.h + 1; y++) {
          for (let x = 0; x < vp.w + 1; x++) {
            const mapX = Math.floor(camera.x) + x, mapY = Math.floor(camera.y) + y;
            if (mapX >= 0 && mapX < MAP_WIDTH && mapY >= 0 && mapY < MAP_HEIGHT) {
              const tile = map[mapY][mapX];
              const screenX = (x - (camera.x % 1)) * TILE_SIZE, screenY = (y - (camera.y % 1)) * TILE_SIZE;

              // ── Natural grass base ─────────────────
              const gh = ((mapX * 1234567 + mapY * 891011) >>> 0) % 100;
              const grassBases = ['#4e7c2b', '#527f2e', '#4a7828', '#568231', '#4c7a2c'];
              ctx.fillStyle = grassBases[gh % 5];
              ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);

              // Grass details only where grass is visible (skip water/path)
              if (tile !== TILES.WATER && tile !== TILES.PATH && tile !== TILES.GOLDEN_GATE) {
                if (gh < 18) {
                  ctx.fillStyle = 'rgba(90,62,28,0.18)';
                  ctx.fillRect(screenX + (gh * 5) % 44, screenY + (gh * 7) % 44, 14, 12);
                }
                ctx.fillStyle = '#3a6020';
                for (let bi = 0; bi < 5; bi++) {
                  ctx.fillRect(screenX + (gh*(bi+1)*13+mapX)%58+2, screenY + (gh*(bi+1)*7+mapY)%56+2, 2, 5);
                }
                ctx.fillStyle = '#6aaa3e';
                for (let bi = 0; bi < 3; bi++) {
                  ctx.fillRect(screenX + (gh*(bi+4)*17)%58+2, screenY + (gh*(bi+4)*11)%56+2, 2, 3);
                }
              }

              switch (tile) {
                case TILES.WATER:
                  ctx.fillStyle = (gameTime + mapX + mapY) % 20 < 10 ? COLORS.water : COLORS.waterLight;
                  ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                  ctx.fillStyle = 'rgba(255,255,255,0.12)';
                  ctx.fillRect(screenX + ((gameTime + mapX*3)%48)+4, screenY + ((gameTime*2+mapY*5)%48)+4, 18, 4);
                  break;
                case TILES.FLOWER:
                  ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
                  ctx.fillStyle = mapX % 2 === 0 ? COLORS.flower : COLORS.flowerYellow;
                  ctx.beginPath(); ctx.arc(16, 18, 5, 0, Math.PI * 2); ctx.fill();
                  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(16, 18, 2, 0, Math.PI * 2); ctx.fill();
                  ctx.restore();
                  break;
                case TILES.PATH: {
                  const ph = ((mapX * 2345 + mapY * 6789) >>> 0) % 100;
                  ctx.fillStyle = '#9b7d52';
                  ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                  ctx.fillStyle = '#7a6040';
                  for (let pi = 0; pi < 4; pi++) ctx.fillRect(screenX + (ph*(pi+1)*11)%56+4, screenY + (ph*(pi+1)*7)%56+4, 5, 3);
                  ctx.fillStyle = '#c0a070';
                  for (let pi = 0; pi < 3; pi++) ctx.fillRect(screenX + (ph*(pi+4)*17)%56+4, screenY + (ph*(pi+4)*13)%56+4, 3, 2);
                  break;
                }
                case TILES.ROCK:
                  ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
                  ctx.fillStyle = COLORS.rock; ctx.beginPath(); ctx.ellipse(16, 20, 10, 8, 0, 0, Math.PI * 2); ctx.fill();
                  ctx.restore();
                  break;
                case TILES.BUSH:
                  ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
                  ctx.fillStyle = COLORS.bush; ctx.beginPath(); ctx.arc(16, 20, 10, 0, Math.PI * 2); ctx.fill();
                  ctx.restore();
                  break;
                case TILES.GOLDEN_GATE:
                  // Path ground under the gate (drawn in pass 1)
                  ctx.fillStyle = '#9b7d52'; ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                  tallObjects.push({ tile, screenX, screenY });
                  break;
                case TILES.TREE:
                case TILES.TREE_OF_LIFE:
                case TILES.TREE_OF_KNOWLEDGE:
                  // Defer to pass 2 so they draw on top of all ground
                  tallObjects.push({ tile, screenX, screenY, mapX });
                  break;
              }
            }
          }
        }

        // ── PASS 2: Tall objects (trees, gate) drawn over all ground ──────
        tallObjects.forEach(({ tile, screenX, screenY, mapX }) => {
          switch (tile) {
            case TILES.TREE:
              ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
              // draw trunk + canopy base so the tile looks solid, then overlay emoji
              ctx.fillStyle = COLORS.treeTrunk; ctx.fillRect(12, 16, 8, 16);
              ctx.fillStyle = COLORS.tree;
              ctx.beginPath(); ctx.arc(16, 12, 14, 0, Math.PI * 2); ctx.fill();
              ctx.fillStyle = 'rgba(255,255,255,0.10)';
              ctx.beginPath(); ctx.arc(13, 8, 7, 0, Math.PI * 2); ctx.fill();
              // emoji overlay for visual appeal
              ctx.font = '20px serif';
              ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
              ctx.fillText('🌳', 16, 12);
              ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
              ctx.restore();
              break;
            case TILES.TREE_OF_LIFE:
              ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
              ctx.fillStyle = '#654321'; ctx.fillRect(8, 10, 16, 22);
              ctx.fillStyle = COLORS.treeOfLife; ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 20 + Math.sin(gameTime * 0.1) * 8;
              ctx.beginPath(); ctx.arc(16, 4, 22, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
              ctx.fillStyle = '#ffd700'; ctx.font = 'bold 7px monospace'; ctx.textAlign = 'center';
              ctx.fillText('ETS CHAYIM', 16, 30); ctx.textAlign = 'left';
              ctx.restore();
              break;
            case TILES.TREE_OF_KNOWLEDGE:
              ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
              ctx.fillStyle = '#4a3520'; ctx.fillRect(8, 10, 16, 22);
              ctx.fillStyle = '#1a3a1a'; ctx.beginPath(); ctx.arc(16, 4, 22, 0, Math.PI * 2); ctx.fill();
              ctx.fillStyle = '#cc0000';
              [[8,2],[24,0],[16,8],[6,10],[26,8]].forEach(([fx,fy]) => { ctx.beginPath(); ctx.arc(fx, fy, 4, 0, Math.PI * 2); ctx.fill(); });
              ctx.fillStyle = '#ff6666'; ctx.font = 'bold 6px monospace'; ctx.textAlign = 'center';
              ctx.fillText("ETS HADA'AT", 16, 30);
              ctx.fillText("TOV V'RA", 16, 37); ctx.textAlign = 'left';
              ctx.restore();
              break;
            case TILES.GOLDEN_GATE: {
              ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
              const glowPulse = 0.5 + 0.5 * Math.sin(gameTime * 0.07);
              ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 18 + glowPulse * 12;
              const pillarGrad = ctx.createLinearGradient(4, 0, 10, 0);
              pillarGrad.addColorStop(0, '#8b6914'); pillarGrad.addColorStop(0.3, '#ffd700'); pillarGrad.addColorStop(0.7, '#ffec6e'); pillarGrad.addColorStop(1, '#b8860b');
              ctx.fillStyle = pillarGrad; ctx.fillRect(4, -26, 6, 58);
              const pillarGrad2 = ctx.createLinearGradient(22, 0, 28, 0);
              pillarGrad2.addColorStop(0, '#b8860b'); pillarGrad2.addColorStop(0.3, '#ffec6e'); pillarGrad2.addColorStop(0.7, '#ffd700'); pillarGrad2.addColorStop(1, '#8b6914');
              ctx.fillStyle = pillarGrad2; ctx.fillRect(22, -26, 6, 58);
              ctx.fillStyle = '#ffd700';
              ctx.fillRect(2, -29, 10, 4); ctx.fillRect(20, -29, 10, 4);
              ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 4;
              ctx.beginPath(); ctx.arc(16, -26, 12, Math.PI, 0); ctx.stroke();
              ctx.lineWidth = 2; ctx.strokeStyle = '#fff8dc';
              ctx.beginPath(); ctx.arc(16, -26, 10, Math.PI, 0); ctx.stroke();
              ctx.strokeStyle = '#daa520'; ctx.lineWidth = 1.5;
              for (let bx = 11; bx <= 21; bx += 2) {
                ctx.beginPath(); ctx.moveTo(bx, -22); ctx.lineTo(bx, 28); ctx.stroke();
              }
              ctx.fillStyle = '#ffd700'; ctx.fillRect(10, -6, 12, 2);
              ctx.shadowBlur = 0; ctx.fillStyle = '#fff8a0';
              ctx.beginPath(); ctx.arc(16, -26, 3, 0, Math.PI * 2); ctx.fill();
              ctx.fillStyle = '#ffd700';
              [[0,-4],[4,3],[-4,3],[2,-3],[-2,-3]].forEach(([ox,oy]) => {
                ctx.beginPath(); ctx.arc(16+ox, -26+oy, 1, 0, Math.PI*2); ctx.fill();
              });
              ctx.shadowBlur = 0;
              ctx.restore();
              break;
            }
          }
        });

        npcs.forEach(npc => {
          const screenX = (npc.x - camera.x) * TILE_SIZE, screenY = (npc.y - camera.y) * TILE_SIZE;
          if (screenX > -TILE_SIZE * 2 && screenX < canvas.width + TILE_SIZE * 2 && screenY > -TILE_SIZE * 2 && screenY < canvas.height + TILE_SIZE * 2) {
            // All sprite drawing scaled 2× inside this block
            ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
            if (npc.isSerpent) {
              ctx.fillStyle = npc.color;
              const wave = Math.sin(gameTime * 0.2) * 3;
              for (let i = 0; i < 3; i++) { ctx.beginPath(); ctx.arc(16 - i * 7, 20 + Math.sin(gameTime * 0.2 + i) * 2, 5 - i, 0, Math.PI * 2); ctx.fill(); }
              ctx.beginPath(); ctx.arc(22, 18 + wave, 6, 0, Math.PI * 2); ctx.fill();
              ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(25, 16 + wave, 2, 0, Math.PI * 2); ctx.fill();
            } else if (npc.isAngel) {
              ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 8;
              ctx.fillStyle = '#fff8dc';
              ctx.beginPath(); ctx.ellipse(3,  15, 8, 11, -0.3, 0, Math.PI * 2); ctx.fill();
              ctx.beginPath(); ctx.ellipse(29, 15, 8, 11,  0.3, 0, Math.PI * 2); ctx.fill();
              ctx.shadowBlur = 0;
              drawCharacterSprite(ctx, 0, 0, {
                walkFrame: npc.walkFrame, isMoving: npc.isMoving, direction: npc.direction || 'down',
                hairColor: '#1a1a1a', bodyColor: '#ffffff', skinColor: SKIN_COLOR,
                isEve: false, showClothes: false, gameTime,
              });
              ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2;
              ctx.beginPath(); ctx.ellipse(16, -3, 8, 3, 0, 0, Math.PI * 2); ctx.stroke();
            } else {
              const showClothes = npc.hasClothes || (npc.clothesBlink > 0 && Math.floor(npc.clothesBlink * 3) % 2 === 0);
              drawCharacterSprite(ctx, 0, 0, {
                walkFrame: npc.walkFrame, isMoving: npc.isMoving, direction: npc.direction || 'down',
                hairColor: npc.hairColor, bodyColor: npc.isEve ? '#c07080' : '#6b8c42', skinColor: SKIN_COLOR,
                isEve: npc.isEve, showClothes,
                holdingFruit: npc.holdingFruit, isEating: npc.isEating,
                hasGlory: npc.hasGlory, gameTime,
              });
            }
            ctx.restore();
            // Name tag and speech bubble drawn at screen coords (outside scale block)
            const cx = screenX + TILE_SIZE / 2;
            if (!showDialogue && gamePhase === PHASES.EXPLORE) drawSpeechBubble(ctx, cx, screenY, npc.thoughts[npc.currentThought], npc.isSerpent);
            const nameText = npc.hasSpoken ? `✓ ${npc.name}` : npc.name;
            ctx.font = 'bold 14px sans-serif';
            const nameWidth = ctx.measureText(nameText).width + 12;
            const nameBoxH = 20, nameBoxY = screenY + 68;
            ctx.fillStyle = npc.hasSpoken ? 'rgba(0,100,0,0.85)' : 'rgba(0,0,0,0.75)';
            ctx.beginPath();
            ctx.roundRect(cx - nameWidth / 2, nameBoxY, nameWidth, nameBoxH, 5);
            ctx.fill();
            ctx.fillStyle = npc.isSerpent ? '#aaffaa' : '#fff';
            ctx.fillText(nameText, cx - nameWidth / 2 + 6, nameBoxY + 14);
          }
        });

        if (gamePhase === PHASES.EXPLORE) {
          const playerScreenX = (player.x - camera.x) * TILE_SIZE, playerScreenY = (player.y - camera.y) * TILE_SIZE;
          ctx.save(); ctx.translate(playerScreenX, playerScreenY); ctx.scale(SCALE, SCALE);
          drawCharacterSprite(ctx, 0, 0, {
            walkFrame: player.walkFrame, isMoving: player.isMoving, direction: player.direction,
            hairColor: '#1a1a1a', bodyColor: '#4169e1', skinColor: SKIN_COLOR,
            gameTime,
          });
          ctx.restore();

          // ── Off-screen NPC direction arrows ────────────────────────
          const margin = 40;
          npcs.forEach(npc => {
            if (npc.id === 'malak') return; // don't point to the angel
            if (npc.hasSpoken) return;       // already spoken to
            const sx = (npc.x - camera.x) * TILE_SIZE;
            const sy = (npc.y - camera.y) * TILE_SIZE;
            const onScreen = sx > -TILE_SIZE && sx < W + TILE_SIZE && sy > -TILE_SIZE && sy < H + TILE_SIZE;
            if (onScreen) return;
            // Clamp to screen edge
            const ax = Math.max(margin, Math.min(W - margin, sx));
            const ay = Math.max(margin + 30, Math.min(H - margin - 90, sy));
            const angle = Math.atan2(sy - H / 2, sx - W / 2);
            const arrowColor = npc.isSerpent ? '#5aff5a' : '#facc15';
            ctx.save();
            ctx.translate(ax, ay);
            ctx.rotate(angle);
            ctx.fillStyle = arrowColor;
            ctx.globalAlpha = 0.6 + 0.2 * Math.sin(gameTime * 0.15);
            ctx.beginPath();
            ctx.moveTo(14, 0);
            ctx.lineTo(-6, -8);
            ctx.lineTo(-6, 8);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.restore();
            // Label
            ctx.font = 'bold 11px sans-serif';
            ctx.fillStyle = arrowColor;
            ctx.globalAlpha = 0.8;
            ctx.fillText(npc.name, ax - ctx.measureText(npc.name).width / 2, ay + 18);
            ctx.globalAlpha = 1;
          });
        }

      }, [map, player, npcs, camera, showDialogue, gameTime, gamePhase, cutsceneSlide]);

      const spokenCount = npcs.filter(n => ['adam', 'chavvah', 'nachash'].includes(n.id) && n.hasSpoken).length;

      return (
        <div className="game-container">
          {gamePhase !== PHASES.CUTSCENE && <h1 className="title">BERE'SHIYTH: In The Beginning</h1>}
          <canvas ref={canvasRef} />

          {gamePhase === PHASES.CUTSCENE && (() => {
            const slide = CUTSCENE_SLIDES[cutsceneSlide];
            return (
              <div className="cutscene-overlay">
                <div className="cutscene-header">
                  {slide.day && <p className="cutscene-day">{slide.day}</p>}
                </div>
                <span className="cutscene-counter">{cutsceneSlide + 1} / {CUTSCENE_SLIDES.length}</span>
                <div className="cutscene-box">
                  <p className="cutscene-ref">{slide.ref}</p>
                  {slide.lines.map((line, i) => <p key={i} className="cutscene-verse">{line}</p>)}
                  <button className="cutscene-btn" onClick={advanceCutscene}>
                    {cutsceneSlide < CUTSCENE_SLIDES.length - 1 ? 'Continue \u25B6' : 'Enter the Garden \u25B6'}
                  </button>
                </div>
              </div>
            );
          })()}

          {showDialogue && (
            <div className="dialogue-box">
              <div className="dialogue-header">
                <span className="dialogue-name">{showDialogue.name}</span>
                <span className="dialogue-counter">{showDialogue.currentDialogue + 1}/{npcs.find(n => n.id === showDialogue.id)?.dialogue.length}</span>
              </div>
              <p className="dialogue-text">{npcs.find(n => n.id === showDialogue.id)?.dialogue[showDialogue.currentDialogue]}</p>
              <button className="btn" onClick={advanceDialogue}>
                {showDialogue.currentDialogue < (npcs.find(n => n.id === showDialogue.id)?.dialogue.length || 1) - 1 ? 'Next ▶' : 'Close ✓'}
              </button>
            </div>
          )}

          {showSceneText && !showDialogue && (
            <div className="dialogue-box">
              <p className="scene-text">{sceneText}</p>
              <button className="btn" onClick={() => { if (gamePhase !== PHASES.EXPLORE) advanceScene(); else setShowSceneText(false); }}>
                {gamePhase === PHASES.EXPLORE ? 'Begin ▶' : 'Continue ▶'}
              </button>
            </div>
          )}

          {gamePhase === PHASES.EXPLORE && !showDialogue && !showSceneText && (
            <p className="quest-text">Speak to A'dam, Chavvah, and the Nachash ({spokenCount}/3)</p>
          )}

          {gamePhase === PHASES.EXPLORE && !showDialogue && !showSceneText && (
            <div className="controls">
              <div className="dpad">
                <div></div>
                <button className="dpad-btn" onTouchStart={(e) => { e.preventDefault(); handleTouchStart('up'); }} onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }} onMouseDown={() => handleTouchStart('up')} onMouseUp={handleTouchEnd} onMouseLeave={handleTouchEnd}>▲</button>
                <div></div>
                <button className="dpad-btn" onTouchStart={(e) => { e.preventDefault(); handleTouchStart('left'); }} onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }} onMouseDown={() => handleTouchStart('left')} onMouseUp={handleTouchEnd} onMouseLeave={handleTouchEnd}>◀</button>
                <div></div>
                <button className="dpad-btn" onTouchStart={(e) => { e.preventDefault(); handleTouchStart('right'); }} onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }} onMouseDown={() => handleTouchStart('right')} onMouseUp={handleTouchEnd} onMouseLeave={handleTouchEnd}>▶</button>
                <div></div>
                <button className="dpad-btn" onTouchStart={(e) => { e.preventDefault(); handleTouchStart('down'); }} onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }} onMouseDown={() => handleTouchStart('down')} onMouseUp={handleTouchEnd} onMouseLeave={handleTouchEnd}>▼</button>
                <div></div>
              </div>
              <button className="talk-btn" onClick={handleInteraction}>TALK</button>
            </div>
          )}

          {gamePhase !== PHASES.EXPLORE && (
            <p className="phase-indicator">{gamePhase === PHASES.COMPLETE ? '📖 The Fall of Man' : '📖 Scene in Progress...'}</p>
          )}

          <p className="help-text">WASD/Arrows to move • SPACE to interact</p>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<GenesisGame />);
  </script>
</body>
</html>
