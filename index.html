<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>BERE'SHIYTH: In The Beginning</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      -webkit-user-select: none;
      user-select: none;
      touch-action: manipulation;
    }
    #root { width: 100%; }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 8px;
    }
    .title {
      font-size: 1.25rem;
      font-weight: bold;
      color: #ffd700;
      margin-bottom: 8px;
      font-family: Georgia, serif;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      letter-spacing: 2px;
    }
    canvas {
      border: 4px solid #8b4513;
      border-radius: 8px;
      image-rendering: pixelated;
      max-width: 100%;
      box-shadow: 0 0 20px rgba(139, 69, 19, 0.5), inset 0 0 10px rgba(0,0,0,0.3);
    }
    .dialogue-box {
      width: 100%;
      max-width: 28rem;
      margin-top: 8px;
      background: linear-gradient(180deg, #2a2a4a 0%, #1a1a3a 100%);
      border: 3px solid #ffd700;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }
    .dialogue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .dialogue-name {
      color: #ffd700;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
    .dialogue-counter {
      color: #888;
      font-size: 0.75rem;
    }
    .dialogue-text {
      color: #fff;
      font-size: 0.875rem;
      margin-bottom: 12px;
      line-height: 1.4;
    }
    .scene-text {
      color: #fde047;
      font-size: 0.875rem;
      font-style: italic;
      margin-bottom: 12px;
      font-family: Georgia, serif;
      line-height: 1.4;
    }
    .btn {
      width: 100%;
      background: linear-gradient(180deg, #ffd700 0%, #daa520 100%);
      color: #1a1a2e;
      font-weight: bold;
      padding: 10px 16px;
      border-radius: 6px;
      border: 2px solid #8b4513;
      cursor: pointer;
      transition: all 0.2s;
      text-shadow: none;
    }
    .btn:hover { background: linear-gradient(180deg, #ffe44d 0%, #ffd700 100%); }
    .btn:active { transform: scale(0.98); }
    .quest-text {
      margin-top: 8px;
      color: #ffd700;
      font-size: 0.75rem;
      text-align: center;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
    .controls {
      margin-top: 12px;
      display: flex;
      gap: 32px;
      align-items: center;
    }
    .dpad {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 4px;
    }
    .dpad-btn {
      width: 52px;
      height: 52px;
      background: linear-gradient(180deg, #3a3a5a 0%, #2a2a4a 100%);
      border: 3px solid #555;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
      color: #ddd;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .dpad-btn:active {
      background: linear-gradient(180deg, #4a4a6a 0%, #3a3a5a 100%);
      border-color: #ffd700;
      transform: scale(0.95);
    }
    .talk-btn {
      width: 64px;
      height: 64px;
      background: linear-gradient(180deg, #ffd700 0%, #daa520 100%);
      border: 4px solid #8b4513;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #1a1a2e;
      font-weight: bold;
      font-size: 0.8rem;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    .talk-btn:active { transform: scale(0.95); }
    .phase-indicator {
      margin-top: 8px;
      color: #ff6b6b;
      font-size: 0.75rem;
      font-weight: bold;
      text-transform: uppercase;
      text-align: center;
    }
    .help-text {
      margin-top: 8px;
      color: #666;
      font-size: 0.7rem;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;

    const TILE_SIZE = 32;
    const MAP_WIDTH = 40;
    const MAP_HEIGHT = 30;
    const VIEWPORT_WIDTH = 14;
    const VIEWPORT_HEIGHT = 10;

    const GARDEN_BOUNDS = { minX: 5, maxX: 35, minY: 5, maxY: 20 };
    const TREE_OF_KNOWLEDGE = { x: 10, y: 10 };

    const TILES = {
      GRASS: 0, WATER: 1, TREE: 2, FLOWER: 3, PATH: 4,
      TREE_OF_LIFE: 5, TREE_OF_KNOWLEDGE: 6, ROCK: 7, BUSH: 8,
      CLIFF_TOP: 9, CLIFF_SIDE: 10, GRASS_DARK: 11
    };

    // DBZ GBC-inspired color palette
    const COLORS = {
      // Terrain colors
      grassLight: '#7ec850',
      grassMid: '#5eb040',
      grassDark: '#3e9030',
      grassShadow: '#2e7020',

      dirtLight: '#d4a574',
      dirtMid: '#b8956a',
      dirtDark: '#9c7850',
      dirtShadow: '#7a5a38',

      cliffLight: '#c9a875',
      cliffMid: '#a8875a',
      cliffDark: '#876840',
      cliffShadow: '#654a28',

      water: '#4a90c8',
      waterLight: '#6ab0e8',
      waterDark: '#3a70a8',
      waterDeep: '#2a5088',

      treeTrunk: '#8b5a2b',
      treeTrunkDark: '#6b4020',
      treeLeaf: '#3a8028',
      treeLeafLight: '#5aa048',
      treeLeafDark: '#2a6018',

      pathLight: '#e8d4a8',
      pathMid: '#d4bc8c',
      pathDark: '#b8a070',

      rock: '#888888',
      rockLight: '#a8a8a8',
      rockDark: '#686868',

      flowerPink: '#ff6090',
      flowerYellow: '#ffe040',
      flowerWhite: '#fff8f0',

      treeOfLife: '#ffd700',
      treeOfLifeGlow: '#fff8c0',
      treeOfKnowledge: '#c00020',
      treeOfKnowledgeDark: '#800010',

      // Character outline
      outline: '#1a1a1a',
    };

    // Character sprite data - DBZ GBC chibi style
    const SPRITE_CONFIG = {
      width: 24,
      height: 32,
      headRatio: 0.4,  // Head takes 40% of height
    };

    // Draw a DBZ-style chibi character
    const drawChibiCharacter = (ctx, x, y, config) => {
      const {
        skinColor = '#c8a882',
        skinShadow = '#a88862',
        hairColor = '#1a1a1a',
        hairHighlight = '#3a3a3a',
        outfitColor = '#4060c0',
        outfitShadow = '#2040a0',
        outfitHighlight = '#6080e0',
        isEve = false,
        isSerpent = false,
        isAngel = false,
        direction = 'down',
        walkFrame = 0,
        isMoving = false,
        hasGlory = false,
        hasClothes = false,
        holdingFruit = false,
        isEating = false,
        clothesBlink = 0,
        gameTime = 0
      } = config;

      const outline = COLORS.outline;

      // Glory aura for Adam and Eve
      if (hasGlory && !isSerpent && !isAngel) {
        const glowIntensity = 0.3 + Math.sin(gameTime * 0.1) * 0.1;
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 20;
        ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity})`;
        ctx.beginPath();
        ctx.ellipse(x + 12, y + 16, 20, 24, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      if (isSerpent) {
        // Serpent - detailed snake with coils
        const wave = Math.sin(gameTime * 0.15) * 2;

        // Body coils
        ctx.fillStyle = '#228b22';
        ctx.strokeStyle = outline;
        ctx.lineWidth = 1;

        // Main body segments
        const segments = [
          { x: x + 4, y: y + 22, r: 5 },
          { x: x + 10, y: y + 24 + wave * 0.3, r: 5 },
          { x: x + 16, y: y + 22 - wave * 0.3, r: 6 },
        ];

        segments.forEach(seg => {
          ctx.beginPath();
          ctx.arc(seg.x, seg.y, seg.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        });

        // Pattern on body
        ctx.fillStyle = '#90ee90';
        segments.forEach(seg => {
          ctx.beginPath();
          ctx.arc(seg.x, seg.y - 1, seg.r * 0.4, 0, Math.PI * 2);
          ctx.fill();
        });

        // Head
        ctx.fillStyle = '#228b22';
        ctx.beginPath();
        ctx.ellipse(x + 20, y + 16 + wave, 7, 6, 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Eyes
        ctx.fillStyle = '#ffff00';
        ctx.beginPath();
        ctx.ellipse(x + 22, y + 14 + wave, 3, 2.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = outline;
        ctx.stroke();

        // Pupil (slit)
        ctx.fillStyle = '#000';
        ctx.fillRect(x + 22, y + 13 + wave, 1, 3);

        // Tongue
        ctx.strokeStyle = '#ff3030';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(x + 26, y + 17 + wave);
        ctx.lineTo(x + 30, y + 16 + wave);
        ctx.moveTo(x + 30, y + 16 + wave);
        ctx.lineTo(x + 32, y + 14 + wave);
        ctx.moveTo(x + 30, y + 16 + wave);
        ctx.lineTo(x + 32, y + 18 + wave);
        ctx.stroke();

        return;
      }

      if (isAngel) {
        // Angel with wings and halo
        // Wings
        ctx.fillStyle = '#f8f8ff';
        ctx.strokeStyle = outline;
        ctx.lineWidth = 1;

        // Left wing
        ctx.beginPath();
        ctx.moveTo(x + 4, y + 16);
        ctx.quadraticCurveTo(x - 8, y + 8, x - 4, y + 4);
        ctx.quadraticCurveTo(x + 2, y + 6, x + 4, y + 16);
        ctx.fill();
        ctx.stroke();

        // Right wing
        ctx.beginPath();
        ctx.moveTo(x + 20, y + 16);
        ctx.quadraticCurveTo(x + 32, y + 8, x + 28, y + 4);
        ctx.quadraticCurveTo(x + 22, y + 6, x + 20, y + 16);
        ctx.fill();
        ctx.stroke();

        // Wing feather details
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 0.5;
        for (let i = 0; i < 3; i++) {
          ctx.beginPath();
          ctx.moveTo(x + 2 - i * 2, y + 14 - i * 3);
          ctx.lineTo(x - 2 - i * 2, y + 8 - i * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x + 22 + i * 2, y + 14 - i * 3);
          ctx.lineTo(x + 26 + i * 2, y + 8 - i * 2);
          ctx.stroke();
        }

        // Halo
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(x + 12, y + 2, 8, 3, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.strokeStyle = '#ffec80';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(x + 12, y + 2, 6, 2, 0, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Walk animation offsets
      let legOffset = 0;
      let bodyBob = 0;
      let armSwing = 0;

      if (isMoving) {
        const frame = Math.floor(walkFrame) % 4;
        legOffset = [0, 3, 0, -3][frame];
        bodyBob = [0, -1, 0, -1][frame];
        armSwing = [0, 2, 0, -2][frame];
      }

      // Body/Outfit
      const showClothes = hasClothes || (clothesBlink > 0 && Math.floor(clothesBlink * 3) % 2 === 0);

      if (!showClothes && !isAngel) {
        // Naked body (skin color)
        ctx.fillStyle = skinColor;
        ctx.strokeStyle = outline;
        ctx.lineWidth = 1;

        // Torso
        ctx.beginPath();
        ctx.roundRect(x + 6, y + 12 + bodyBob, 12, 12, 2);
        ctx.fill();
        ctx.stroke();
      } else {
        // Clothed body or fig leaves
        ctx.fillStyle = isAngel ? '#f0f0ff' : (hasClothes ? '#6b8e23' : outfitColor);
        ctx.strokeStyle = outline;
        ctx.lineWidth = 1;

        // Torso
        ctx.beginPath();
        ctx.roundRect(x + 6, y + 12 + bodyBob, 12, 12, 2);
        ctx.fill();
        ctx.stroke();

        // Outfit details
        if (isAngel) {
          ctx.fillStyle = '#e0e0f0';
          ctx.fillRect(x + 8, y + 14 + bodyBob, 8, 3);
        } else if (hasClothes) {
          // Fig leaf pattern
          ctx.fillStyle = '#4a6b13';
          ctx.beginPath();
          ctx.moveTo(x + 12, y + 14 + bodyBob);
          ctx.lineTo(x + 8, y + 20 + bodyBob);
          ctx.lineTo(x + 16, y + 20 + bodyBob);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.fillStyle = outfitShadow;
          ctx.fillRect(x + 6, y + 20 + bodyBob, 12, 4);
        }
      }

      // Arms
      ctx.fillStyle = skinColor;
      ctx.strokeStyle = outline;
      ctx.lineWidth = 1;

      // Left arm
      ctx.beginPath();
      ctx.roundRect(x + 2, y + 14 + bodyBob - armSwing, 5, 10, 2);
      ctx.fill();
      ctx.stroke();

      // Right arm (may hold fruit)
      if (holdingFruit && !isEating) {
        ctx.beginPath();
        ctx.roundRect(x + 17, y + 12 + bodyBob, 5, 8, 2);
        ctx.fill();
        ctx.stroke();

        // Fruit in hand
        ctx.fillStyle = '#cc0000';
        ctx.strokeStyle = outline;
        ctx.beginPath();
        ctx.arc(x + 22, y + 12 + bodyBob, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = '#6b4020';
        ctx.fillRect(x + 21, y + 7 + bodyBob, 2, 3);
      } else {
        ctx.beginPath();
        ctx.roundRect(x + 17, y + 14 + bodyBob + armSwing, 5, 10, 2);
        ctx.fill();
        ctx.stroke();
      }

      // Legs with walk animation
      ctx.fillStyle = showClothes ? '#6b8e23' : skinColor;
      ctx.strokeStyle = outline;
      ctx.lineWidth = 1;

      // Left leg
      ctx.beginPath();
      ctx.roundRect(x + 7 - legOffset, y + 23, 4, 9, 2);
      ctx.fill();
      ctx.stroke();

      // Right leg
      ctx.beginPath();
      ctx.roundRect(x + 13 + legOffset, y + 23, 4, 9, 2);
      ctx.fill();
      ctx.stroke();

      // Head (large, chibi style)
      ctx.fillStyle = skinColor;
      ctx.strokeStyle = outline;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(x + 12, y + 8 + bodyBob, 9, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Hair
      ctx.fillStyle = hairColor;
      ctx.strokeStyle = outline;
      ctx.lineWidth = 1;

      if (isEve) {
        // Long hair for Eve
        ctx.beginPath();
        ctx.arc(x + 12, y + 6 + bodyBob, 9, Math.PI, 0);
        ctx.fill();
        ctx.stroke();

        // Side hair
        ctx.fillRect(x + 2, y + 6 + bodyBob, 5, 16);
        ctx.strokeRect(x + 2, y + 6 + bodyBob, 5, 16);
        ctx.fillRect(x + 17, y + 6 + bodyBob, 5, 16);
        ctx.strokeRect(x + 17, y + 6 + bodyBob, 5, 16);

        // Hair highlight
        ctx.fillStyle = hairHighlight;
        ctx.beginPath();
        ctx.arc(x + 10, y + 4 + bodyBob, 3, 0, Math.PI * 2);
        ctx.fill();
      } else if (isAngel) {
        // Short neat hair
        ctx.beginPath();
        ctx.arc(x + 12, y + 6 + bodyBob, 9, Math.PI, 0);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = hairHighlight;
        ctx.beginPath();
        ctx.arc(x + 10, y + 4 + bodyBob, 3, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Short spiky hair (DBZ style)
        ctx.beginPath();
        ctx.arc(x + 12, y + 6 + bodyBob, 9, Math.PI, 0);
        ctx.fill();
        ctx.stroke();

        // Spikes
        ctx.beginPath();
        ctx.moveTo(x + 4, y + 4 + bodyBob);
        ctx.lineTo(x + 2, y - 2 + bodyBob);
        ctx.lineTo(x + 8, y + 2 + bodyBob);
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x + 10, y + 2 + bodyBob);
        ctx.lineTo(x + 12, y - 4 + bodyBob);
        ctx.lineTo(x + 14, y + 2 + bodyBob);
        ctx.fill();
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x + 16, y + 4 + bodyBob);
        ctx.lineTo(x + 22, y - 2 + bodyBob);
        ctx.lineTo(x + 20, y + 4 + bodyBob);
        ctx.fill();
        ctx.stroke();

        // Hair highlight
        ctx.fillStyle = hairHighlight;
        ctx.beginPath();
        ctx.arc(x + 9, y + 4 + bodyBob, 2, 0, Math.PI * 2);
        ctx.fill();
      }

      // Face based on direction
      const eyeOffset = {
        up: { x: 0, y: -1 },
        down: { x: 0, y: 1 },
        left: { x: -2, y: 0 },
        right: { x: 2, y: 0 }
      }[direction] || { x: 0, y: 0 };

      // Eyes (large anime style)
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = outline;
      ctx.lineWidth = 1;

      // Left eye
      ctx.beginPath();
      ctx.ellipse(x + 8 + eyeOffset.x, y + 8 + bodyBob + eyeOffset.y, 3, 3.5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Right eye
      ctx.beginPath();
      ctx.ellipse(x + 16 + eyeOffset.x, y + 8 + bodyBob + eyeOffset.y, 3, 3.5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Pupils
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(x + 8 + eyeOffset.x * 1.5, y + 8 + bodyBob + eyeOffset.y, 1.5, 0, Math.PI * 2);
      ctx.arc(x + 16 + eyeOffset.x * 1.5, y + 8 + bodyBob + eyeOffset.y, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Eye shine
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x + 7, y + 7 + bodyBob, 1, 0, Math.PI * 2);
      ctx.arc(x + 15, y + 7 + bodyBob, 1, 0, Math.PI * 2);
      ctx.fill();

      // Mouth
      if (isEating) {
        // Eating animation - open mouth with fruit
        ctx.fillStyle = '#a00';
        ctx.beginPath();
        ctx.arc(x + 12, y + 13 + bodyBob, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = outline;
        ctx.stroke();
      } else {
        // Normal mouth
        ctx.strokeStyle = outline;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(x + 12, y + 12 + bodyBob, 2, 0.1 * Math.PI, 0.9 * Math.PI);
        ctx.stroke();
      }
    };

    // Draw DBZ-style terrain tile
    const drawTerrain = (ctx, x, y, tile, mapX, mapY, gameTime) => {
      const isEvenTile = (mapX + mapY) % 2 === 0;

      switch (tile) {
        case TILES.GRASS:
        case TILES.GRASS_DARK:
          // Base grass with texture
          ctx.fillStyle = isEvenTile ? COLORS.grassLight : COLORS.grassMid;
          ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

          // Grass texture pattern (dithering like GBC)
          ctx.fillStyle = COLORS.grassDark;
          for (let i = 0; i < 8; i++) {
            const gx = (mapX * 7 + i * 5) % TILE_SIZE;
            const gy = (mapY * 11 + i * 3) % TILE_SIZE;
            ctx.fillRect(x + gx, y + gy, 2, 2);
          }

          // Occasional grass blades
          if ((mapX * mapY) % 5 === 0) {
            ctx.strokeStyle = COLORS.grassShadow;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 8, y + TILE_SIZE);
            ctx.lineTo(x + 10, y + TILE_SIZE - 6);
            ctx.moveTo(x + 20, y + TILE_SIZE);
            ctx.lineTo(x + 18, y + TILE_SIZE - 5);
            ctx.stroke();
          }
          break;

        case TILES.PATH:
          // Dirt path with DBZ style
          ctx.fillStyle = COLORS.dirtMid;
          ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

          // Path texture
          ctx.fillStyle = COLORS.dirtLight;
          for (let i = 0; i < 6; i++) {
            const px = (mapX * 5 + i * 7) % (TILE_SIZE - 4);
            const py = (mapY * 3 + i * 5) % (TILE_SIZE - 4);
            ctx.fillRect(x + px, y + py, 3, 2);
          }

          // Dark spots
          ctx.fillStyle = COLORS.dirtShadow;
          for (let i = 0; i < 4; i++) {
            const px = (mapX * 3 + i * 9) % (TILE_SIZE - 2);
            const py = (mapY * 7 + i * 4) % (TILE_SIZE - 2);
            ctx.fillRect(x + px, y + py, 2, 2);
          }
          break;

        case TILES.WATER:
          // Animated water with DBZ style
          const waterPhase = (gameTime + mapX * 3 + mapY * 2) % 30;
          ctx.fillStyle = waterPhase < 10 ? COLORS.water :
                          waterPhase < 20 ? COLORS.waterLight : COLORS.waterDark;
          ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

          // Wave highlights
          ctx.fillStyle = COLORS.waterLight;
          const waveOffset = Math.sin((gameTime + mapX) * 0.2) * 3;
          ctx.beginPath();
          ctx.ellipse(x + 16, y + 10 + waveOffset, 8, 2, 0, 0, Math.PI * 2);
          ctx.fill();

          // Deep water shadows
          ctx.fillStyle = COLORS.waterDeep;
          ctx.fillRect(x, y + TILE_SIZE - 6, TILE_SIZE, 3);
          break;

        case TILES.TREE:
          // Draw grass base first
          ctx.fillStyle = COLORS.grassMid;
          ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

          // Tree trunk with shading
          ctx.fillStyle = COLORS.treeTrunk;
          ctx.fillRect(x + 12, y + 18, 8, 14);
          ctx.fillStyle = COLORS.treeTrunkDark;
          ctx.fillRect(x + 12, y + 18, 3, 14);

          // Tree foliage (layered circles like DBZ)
          ctx.fillStyle = COLORS.treeLeafDark;
          ctx.beginPath();
          ctx.arc(x + 16, y + 14, 14, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = COLORS.treeLeaf;
          ctx.beginPath();
          ctx.arc(x + 16, y + 12, 12, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = COLORS.treeLeafLight;
          ctx.beginPath();
          ctx.arc(x + 13, y + 9, 6, 0, Math.PI * 2);
          ctx.fill();

          // Outline
          ctx.strokeStyle = COLORS.outline;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(x + 16, y + 12, 12, 0, Math.PI * 2);
          ctx.stroke();
          break;

        case TILES.ROCK:
          // Draw grass base first
          ctx.fillStyle = COLORS.grassMid;
          ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

          // Rock with DBZ shading
          ctx.fillStyle = COLORS.rockDark;
          ctx.beginPath();
          ctx.ellipse(x + 16, y + 22, 12, 10, 0, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = COLORS.rock;
          ctx.beginPath();
          ctx.ellipse(x + 15, y + 20, 10, 8, 0, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = COLORS.rockLight;
          ctx.beginPath();
          ctx.ellipse(x + 12, y + 18, 5, 4, -0.3, 0, Math.PI * 2);
          ctx.fill();

          // Outline
          ctx.strokeStyle = COLORS.outline;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(x + 16, y + 22, 12, 10, 0, 0, Math.PI * 2);
          ctx.stroke();
          break;

        case TILES.BUSH:
          // Draw grass base first
          ctx.fillStyle = COLORS.grassMid;
          ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

          // Bush with DBZ style
          ctx.fillStyle = COLORS.treeLeafDark;
          ctx.beginPath();
          ctx.arc(x + 16, y + 22, 11, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = COLORS.treeLeaf;
          ctx.beginPath();
          ctx.arc(x + 14, y + 20, 9, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = COLORS.treeLeafLight;
          ctx.beginPath();
          ctx.arc(x + 11, y + 18, 4, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = COLORS.outline;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(x + 16, y + 22, 11, 0, Math.PI * 2);
          ctx.stroke();
          break;

        case TILES.FLOWER:
          // Draw grass base first
          ctx.fillStyle = isEvenTile ? COLORS.grassLight : COLORS.grassMid;
          ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

          // Flower stem
          ctx.strokeStyle = COLORS.grassDark;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + 16, y + TILE_SIZE);
          ctx.lineTo(x + 16, y + 18);
          ctx.stroke();

          // Flower petals
          const flowerColor = mapX % 3 === 0 ? COLORS.flowerPink :
                             mapX % 3 === 1 ? COLORS.flowerYellow : COLORS.flowerWhite;
          ctx.fillStyle = flowerColor;
          for (let i = 0; i < 5; i++) {
            const angle = (i / 5) * Math.PI * 2;
            ctx.beginPath();
            ctx.arc(x + 16 + Math.cos(angle) * 5, y + 16 + Math.sin(angle) * 5, 3, 0, Math.PI * 2);
            ctx.fill();
          }

          // Flower center
          ctx.fillStyle = '#ffcc00';
          ctx.beginPath();
          ctx.arc(x + 16, y + 16, 3, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = COLORS.outline;
          ctx.lineWidth = 0.5;
          ctx.stroke();
          break;

        case TILES.TREE_OF_LIFE:
          // Draw grass base first
          ctx.fillStyle = COLORS.grassMid;
          ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

          // Glowing trunk
          ctx.shadowColor = COLORS.treeOfLife;
          ctx.shadowBlur = 15;
          ctx.fillStyle = '#8b6914';
          ctx.fillRect(x + 10, y + 12, 12, 20);
          ctx.shadowBlur = 0;

          // Golden foliage
          ctx.fillStyle = COLORS.treeOfLife;
          ctx.shadowColor = COLORS.treeOfLifeGlow;
          ctx.shadowBlur = 20 + Math.sin(gameTime * 0.1) * 8;
          ctx.beginPath();
          ctx.arc(x + 16, y + 6, 18, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;

          // Highlight
          ctx.fillStyle = COLORS.treeOfLifeGlow;
          ctx.beginPath();
          ctx.arc(x + 12, y + 2, 8, 0, Math.PI * 2);
          ctx.fill();

          // Outline
          ctx.strokeStyle = '#8b6914';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x + 16, y + 6, 18, 0, Math.PI * 2);
          ctx.stroke();

          // Label
          ctx.fillStyle = COLORS.treeOfLife;
          ctx.font = 'bold 7px monospace';
          ctx.textAlign = 'center';
          ctx.fillText('ETS CHAYIM', x + 16, y + 40);
          ctx.textAlign = 'left';
          break;

        case TILES.TREE_OF_KNOWLEDGE:
          // Draw grass base first
          ctx.fillStyle = COLORS.grassMid;
          ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

          // Dark trunk
          ctx.fillStyle = '#3a2010';
          ctx.fillRect(x + 10, y + 12, 12, 20);
          ctx.fillStyle = '#2a1008';
          ctx.fillRect(x + 10, y + 12, 4, 20);

          // Dark foliage
          ctx.fillStyle = '#1a3010';
          ctx.beginPath();
          ctx.arc(x + 16, y + 6, 18, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#2a4018';
          ctx.beginPath();
          ctx.arc(x + 14, y + 4, 12, 0, Math.PI * 2);
          ctx.fill();

          // Forbidden fruits
          ctx.fillStyle = COLORS.treeOfKnowledge;
          const fruitPositions = [[8, 2], [24, 0], [16, 8], [6, 10], [26, 8], [18, -2], [10, 6]];
          fruitPositions.forEach(([fx, fy]) => {
            ctx.beginPath();
            ctx.arc(x + fx, y + fy, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = COLORS.treeOfKnowledgeDark;
            ctx.beginPath();
            ctx.arc(x + fx - 1, y + fy + 1, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = COLORS.treeOfKnowledge;
          });

          // Outline
          ctx.strokeStyle = COLORS.outline;
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(x + 16, y + 6, 18, 0, Math.PI * 2);
          ctx.stroke();

          // Label
          ctx.fillStyle = '#ff6666';
          ctx.font = 'bold 6px monospace';
          ctx.textAlign = 'center';
          ctx.fillText("ETS HADA'AT", x + 16, y + 40);
          ctx.fillText("TOV V'RA", x + 16, y + 47);
          ctx.textAlign = 'left';
          break;
      }
    };

    const generateMap = () => {
      const map = [];
      for (let y = 0; y < MAP_HEIGHT; y++) {
        const row = [];
        for (let x = 0; x < MAP_WIDTH; x++) {
          if (y >= 22 && y <= 25) row.push(TILES.WATER);
          else if ((x === 15 && y >= 5 && y <= 20) || (y === 12 && x >= 8 && x <= 28)) row.push(TILES.PATH);
          else if (x < 3 || x > MAP_WIDTH - 4 || y < 3 || y > MAP_HEIGHT - 4) row.push(Math.random() > 0.3 ? TILES.TREE : TILES.GRASS);
          else {
            const rand = Math.random();
            if (rand < 0.05) row.push(TILES.TREE);
            else if (rand < 0.08) row.push(TILES.FLOWER);
            else if (rand < 0.1) row.push(TILES.BUSH);
            else if (rand < 0.11) row.push(TILES.ROCK);
            else row.push(TILES.GRASS);
          }
        }
        map.push(row);
      }
      map[10][28] = TILES.TREE_OF_LIFE;
      map[TREE_OF_KNOWLEDGE.y][TREE_OF_KNOWLEDGE.x] = TILES.TREE_OF_KNOWLEDGE;
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
          if (map[10 + dy]) {
            if (map[10 + dy][28 + dx] !== undefined && map[10 + dy][28 + dx] !== TILES.TREE_OF_LIFE) map[10 + dy][28 + dx] = TILES.GRASS;
            if (map[TREE_OF_KNOWLEDGE.y + dy] && map[TREE_OF_KNOWLEDGE.y + dy][TREE_OF_KNOWLEDGE.x + dx] !== undefined && map[TREE_OF_KNOWLEDGE.y + dy][TREE_OF_KNOWLEDGE.x + dx] !== TILES.TREE_OF_KNOWLEDGE) map[TREE_OF_KNOWLEDGE.y + dy][TREE_OF_KNOWLEDGE.x + dx] = TILES.GRASS;
          }
        }
      }
      return map;
    };

    const SKIN_COLOR = '#c8a882';
    const SKIN_SHADOW = '#a88862';

    const createNPCs = () => [
      {
        id: 'adam', name: "A'dam", x: 20, y: 14, prevX: 20, prevY: 14,
        skinColor: SKIN_COLOR, skinShadow: SKIN_SHADOW,
        hairColor: '#1a1a1a', hairHighlight: '#3a3a3a',
        outfitColor: '#4a6090', outfitShadow: '#3a4070', outfitHighlight: '#6080b0',
        thoughts: ["YAHUAH formed me from the dust...", "I am to dress and keep this garden.", "She is bone of my bones..."],
        dialogue: ["Shalom, traveler. I am A'dam.", "YAHUAH ELOHIYM formed me of the dust of the ground.", "He breathed into my nostrils the breath of life.", "I became a living nephesh.", "YAHUAH put me in the Garden of Eden to dress it and keep it.", "Of every tree I may freely eat...", "But of the Ets HaDa'at Tov v'Ra, I shall not eat.", "For in the day I eat thereof, I shall surely die."],
        currentDialogue: 0, currentThought: 0, thoughtTimer: 0, behavior: 'wander', homeX: 20, homeY: 14, targetX: null, targetY: null, moveTimer: 0, walkFrame: 0, isMoving: false, hasSpoken: false, holdingFruit: false, isEating: false, hasGlory: true, hasClothes: false, clothesBlink: 0, direction: 'down',
      },
      {
        id: 'chavvah', name: 'Chavvah', x: 22, y: 14, prevX: 22, prevY: 14,
        skinColor: SKIN_COLOR, skinShadow: SKIN_SHADOW,
        hairColor: '#1a1a1a', hairHighlight: '#3a3a3a',
        outfitColor: '#905080', outfitShadow: '#704060', outfitHighlight: '#b070a0',
        isEve: true,
        thoughts: ["The garden is so beautiful...", "That tree... the fruit looks good...", "The nachash says we won't die..."],
        dialogue: ["I am Chavvah, the mother of all living.", "YAHUAH ELOHIYM caused a deep sleep upon A'dam.", "He took one of his ribs and made me.", "We may eat of the fruit of the trees of the garden.", "But of the tree in the midst of the garden...", "ELOHIYM has said, Ye shall not eat of it.", "Neither shall ye touch it, lest ye die.", "But the nachash says our eyes will be opened..."],
        currentDialogue: 0, currentThought: 0, thoughtTimer: 0, behavior: 'wander', homeX: 22, homeY: 14, targetX: null, targetY: null, moveTimer: 0, walkFrame: 0, isMoving: false, hasSpoken: false, holdingFruit: false, isEating: false, hasGlory: true, hasClothes: false, clothesBlink: 0, direction: 'down',
      },
      {
        id: 'nachash', name: 'Nachash', x: 10, y: 12, prevX: 10, prevY: 12,
        isSerpent: true,
        thoughts: ["Yea, hath ELOHIYM said...?", "Ye shall not surely die...", "Your eyes shall be opened..."],
        dialogue: ["Yea, hath ELOHIYM said...", "Ye shall not eat of every tree of the garden?", "Ye shall not surely die.", "For ELOHIYM knows that in the day ye eat thereof...", "Your eyes shall be opened.", "And ye shall be as elohiym...", "Knowing good and evil.", "Is the fruit not pleasant to the eyes?"],
        currentDialogue: 0, currentThought: 0, thoughtTimer: 0, behavior: 'circle_tree', circleAngle: 0, targetX: null, targetY: null, moveTimer: 0, walkFrame: 0, isMoving: false, hasSpoken: false, direction: 'right',
      },
      {
        id: 'malak', name: 'Malak', x: 28, y: 8, prevX: 28, prevY: 8,
        skinColor: SKIN_COLOR, skinShadow: SKIN_SHADOW,
        hairColor: '#d4af37', hairHighlight: '#f0d060',
        isAngel: true,
        thoughts: ["Holy, holy, holy is YAHUAH!", "I guard the Ets Chayim.", "The flaming sword turns every way..."],
        dialogue: ["Shalom. I am a malak of YAHUAH.", "I watch over this qodesh garden.", "Behold, the Ets Chayim - the Tree of Life!", "And there - the Ets HaDa'at Tov v'Ra.", "YAHUAH ELOHIYM has forbidden its fruit.", "Guard your heart, child of the Most High."],
        currentDialogue: 0, currentThought: 0, thoughtTimer: 0, behavior: 'patrol', patrolPoints: [{x: 28, y: 8}, {x: 26, y: 10}, {x: 30, y: 10}], patrolIndex: 0, targetX: null, targetY: null, moveTimer: 0, walkFrame: 0, isMoving: false, hasSpoken: false, direction: 'down',
      }
    ];

    const PHASES = {
      EXPLORE: 'explore', SCENE_START: 'scene_start', CHAVVAH_WALKS_TO_TREE: 'chavvah_walks',
      CHAVVAH_TAKES_FRUIT: 'chavvah_takes', CHAVVAH_EATS: 'chavvah_eats', CHAVVAH_GLORY_FADES: 'chavvah_glory_fades',
      CHAVVAH_WALKS_TO_ADAM: 'chavvah_to_adam', ADAM_EATS: 'adam_eats', ADAM_GLORY_FADES: 'adam_glory_fades',
      EYES_OPENED: 'eyes_opened', COMPLETE: 'complete'
    };

    const drawSpeechBubble = (ctx, x, y, text, isSerpent = false) => {
      const maxWidth = 120, padding = 6, lineHeight = 12;
      ctx.font = '9px monospace';
      const words = text.split(' ');
      const lines = [];
      let currentLine = '';
      words.forEach(word => {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        if (ctx.measureText(testLine).width > maxWidth - padding * 2) { if (currentLine) lines.push(currentLine); currentLine = word; }
        else currentLine = testLine;
      });
      if (currentLine) lines.push(currentLine);
      const bubbleWidth = Math.min(maxWidth, Math.max(...lines.map(l => ctx.measureText(l).width)) + padding * 2);
      const bubbleHeight = lines.length * lineHeight + padding * 2;
      const bubbleX = x - bubbleWidth / 2, bubbleY = y - bubbleHeight - 20;

      // Bubble background with gradient effect
      ctx.fillStyle = isSerpent ? 'rgba(20, 40, 20, 0.95)' : 'rgba(255, 255, 255, 0.95)';
      ctx.strokeStyle = isSerpent ? '#4a7c4a' : '#333';
      ctx.lineWidth = 2;

      const radius = 8;
      ctx.beginPath();
      ctx.moveTo(bubbleX + radius, bubbleY);
      ctx.lineTo(bubbleX + bubbleWidth - radius, bubbleY);
      ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + radius);
      ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - radius);
      ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - radius, bubbleY + bubbleHeight);
      ctx.lineTo(bubbleX + radius, bubbleY + bubbleHeight);
      ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - radius);
      ctx.lineTo(bubbleX, bubbleY + radius);
      ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + radius, bubbleY);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Thought bubbles
      ctx.fillStyle = isSerpent ? 'rgba(20, 40, 20, 0.95)' : 'rgba(255, 255, 255, 0.95)';
      ctx.beginPath(); ctx.arc(x - 4, bubbleY + bubbleHeight + 5, 4, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.arc(x, bubbleY + bubbleHeight + 11, 3, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

      // Text
      ctx.fillStyle = isSerpent ? '#90EE90' : '#333';
      ctx.font = '9px monospace';
      lines.forEach((line, i) => { ctx.fillText(line, bubbleX + padding, bubbleY + padding + lineHeight * (i + 0.8)); });
    };

    const GenesisGame = () => {
      const canvasRef = useRef(null);
      const [map] = useState(generateMap);
      const [player, setPlayer] = useState({ x: 17, y: 16, prevX: 17, prevY: 16, direction: 'down', walkFrame: 0, isMoving: false });
      const [npcs, setNpcs] = useState(createNPCs);
      const [camera, setCamera] = useState({ x: 0, y: 0 });
      const [showDialogue, setShowDialogue] = useState(null);
      const [sceneText, setSceneText] = useState("Bere'shiyth - In the beginning ELOHIYM created the heavens and the earth...");
      const [showSceneText, setShowSceneText] = useState(true);
      const [gameTime, setGameTime] = useState(0);
      const [gamePhase, setGamePhase] = useState(PHASES.EXPLORE);
      const keysPressed = useRef({});
      const [touchDirection, setTouchDirection] = useState(null);

      const checkSceneTrigger = useCallback(() => {
        const adam = npcs.find(n => n.id === 'adam');
        const chavvah = npcs.find(n => n.id === 'chavvah');
        const nachash = npcs.find(n => n.id === 'nachash');
        return adam?.hasSpoken && chavvah?.hasSpoken && nachash?.hasSpoken;
      }, [npcs]);

      const canNPCMoveTo = useCallback((x, y) => {
        if (x < GARDEN_BOUNDS.minX || x > GARDEN_BOUNDS.maxX || y < GARDEN_BOUNDS.minY || y > GARDEN_BOUNDS.maxY) return false;
        if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return false;
        const tile = map[Math.floor(y)][Math.floor(x)];
        return tile !== TILES.WATER && tile !== TILES.TREE && tile !== TILES.ROCK && tile !== TILES.TREE_OF_LIFE && tile !== TILES.TREE_OF_KNOWLEDGE;
      }, [map]);

      const canMoveTo = useCallback((x, y) => {
        if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return false;
        const tile = map[Math.floor(y)][Math.floor(x)];
        return tile !== TILES.WATER && tile !== TILES.TREE && tile !== TILES.ROCK && tile !== TILES.TREE_OF_LIFE && tile !== TILES.TREE_OF_KNOWLEDGE;
      }, [map]);

      useEffect(() => {
        setCamera({
          x: Math.max(0, Math.min(player.x - VIEWPORT_WIDTH / 2, MAP_WIDTH - VIEWPORT_WIDTH)),
          y: Math.max(0, Math.min(player.y - VIEWPORT_HEIGHT / 2, MAP_HEIGHT - VIEWPORT_HEIGHT))
        });
      }, [player]);

      const advanceDialogue = useCallback(() => {
        if (!showDialogue) return;
        const currentNpc = npcs.find(n => n.id === showDialogue.id);
        if (currentNpc) {
          const nextDialogue = showDialogue.currentDialogue + 1;
          if (nextDialogue >= currentNpc.dialogue.length) {
            setShowDialogue(null);
            setNpcs(prev => prev.map(npc => npc.id === currentNpc.id ? { ...npc, hasSpoken: true, currentDialogue: 0 } : npc));
          } else {
            setShowDialogue({ ...showDialogue, currentDialogue: nextDialogue });
          }
        }
      }, [showDialogue, npcs]);

      const handleInteraction = useCallback(() => {
        if (showDialogue) { advanceDialogue(); return; }
        if (showSceneText) { setShowSceneText(false); return; }
        if (gamePhase === PHASES.EXPLORE) {
          const nearbyNpc = npcs.find(npc => Math.abs(npc.x - player.x) < 1.5 && Math.abs(npc.y - player.y) < 1.5);
          if (nearbyNpc) setShowDialogue({ ...nearbyNpc, currentDialogue: 0 });
        }
      }, [showDialogue, showSceneText, gamePhase, npcs, player, advanceDialogue]);

      const advanceScene = useCallback(() => {
        setShowSceneText(false);
        switch (gamePhase) {
          case PHASES.SCENE_START:
            setGamePhase(PHASES.CHAVVAH_WALKS_TO_TREE);
            setSceneText("And when the woman saw that the tree was good for food, and pleasant to the eyes...");
            setShowSceneText(true);
            break;
          case PHASES.CHAVVAH_TAKES_FRUIT:
            setNpcs(prev => prev.map(npc => npc.id === 'chavvah' ? { ...npc, holdingFruit: true } : npc));
            setGamePhase(PHASES.CHAVVAH_EATS);
            setSceneText("She took of the fruit thereof...");
            setShowSceneText(true);
            break;
          case PHASES.CHAVVAH_EATS:
            setNpcs(prev => prev.map(npc => npc.id === 'chavvah' ? { ...npc, isEating: true } : npc));
            setTimeout(() => {
              setNpcs(prev => prev.map(npc => npc.id === 'chavvah' ? { ...npc, isEating: false } : npc));
              setGamePhase(PHASES.CHAVVAH_GLORY_FADES);
              setSceneText("And did eat... and the glory of YAHUAH departed from her...");
              setShowSceneText(true);
              setTimeout(() => {
                setNpcs(prev => prev.map(npc => npc.id === 'chavvah' ? { ...npc, hasGlory: false, clothesBlink: 4 } : npc));
              }, 500);
            }, 1500);
            break;
          case PHASES.CHAVVAH_GLORY_FADES:
            setGamePhase(PHASES.CHAVVAH_WALKS_TO_ADAM);
            setSceneText("And gave also unto her husband with her...");
            setShowSceneText(true);
            break;
          case PHASES.ADAM_EATS:
            setNpcs(prev => prev.map(npc => npc.id === 'adam' ? { ...npc, holdingFruit: true, isEating: true } : npc));
            setTimeout(() => {
              setNpcs(prev => prev.map(npc => npc.id === 'adam' ? { ...npc, isEating: false } : npc));
              setGamePhase(PHASES.ADAM_GLORY_FADES);
              setSceneText("And he did eat... and the glory departed from him also...");
              setShowSceneText(true);
              setTimeout(() => {
                setNpcs(prev => prev.map(npc => npc.id === 'adam' ? { ...npc, hasGlory: false, clothesBlink: 4 } : npc));
              }, 500);
            }, 1500);
            break;
          case PHASES.ADAM_GLORY_FADES:
            setGamePhase(PHASES.EYES_OPENED);
            setSceneText("And the eyes of them both were opened, and they knew that they were naked...");
            setShowSceneText(true);
            break;
          case PHASES.EYES_OPENED:
            setGamePhase(PHASES.COMPLETE);
            setSceneText("And they sewed fig leaves together, and made themselves aprons...");
            setShowSceneText(true);
            break;
        }
      }, [gamePhase]);

      useEffect(() => {
        const handleKeyDown = (e) => {
          keysPressed.current[e.key.toLowerCase()] = true;
          if (e.key === ' ' || e.key === 'Enter') {
            e.preventDefault();
            if (showSceneText && gamePhase !== PHASES.EXPLORE) advanceScene();
            else handleInteraction();
          }
        };
        const handleKeyUp = (e) => { keysPressed.current[e.key.toLowerCase()] = false; };
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        return () => { window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); };
      }, [handleInteraction, advanceScene, showSceneText, gamePhase]);

      const handleTouchStart = (direction) => setTouchDirection(direction);
      const handleTouchEnd = () => setTouchDirection(null);

      useEffect(() => {
        const gameLoop = setInterval(() => {
          setGameTime(prev => prev + 1);
          if (gamePhase === PHASES.EXPLORE && checkSceneTrigger()) {
            setGamePhase(PHASES.SCENE_START);
            setSceneText("The nachash beguiled Chavvah... she looked upon the forbidden tree...");
            setShowSceneText(true);
          }
          if (!showDialogue && gamePhase === PHASES.EXPLORE) {
            setPlayer(prev => {
              let newX = prev.x, newY = prev.y, newDir = prev.direction;
              const speed = 0.15;
              const up = keysPressed.current['w'] || keysPressed.current['arrowup'] || touchDirection === 'up';
              const down = keysPressed.current['s'] || keysPressed.current['arrowdown'] || touchDirection === 'down';
              const left = keysPressed.current['a'] || keysPressed.current['arrowleft'] || touchDirection === 'left';
              const right = keysPressed.current['d'] || keysPressed.current['arrowright'] || touchDirection === 'right';
              if (up) { newY -= speed; newDir = 'up'; }
              if (down) { newY += speed; newDir = 'down'; }
              if (left) { newX -= speed; newDir = 'left'; }
              if (right) { newX += speed; newDir = 'right'; }
              let finalX = prev.x, finalY = prev.y;
              if (canMoveTo(newX, newY)) { finalX = newX; finalY = newY; }
              else if (canMoveTo(newX, prev.y)) { finalX = newX; }
              else if (canMoveTo(prev.x, newY)) { finalY = newY; }
              const isMoving = finalX !== prev.x || finalY !== prev.y;
              const walkFrame = isMoving ? (prev.walkFrame + 0.3) % 4 : 0;
              return { x: finalX, y: finalY, prevX: prev.x, prevY: prev.y, direction: newDir, walkFrame, isMoving };
            });
          }
          if (!showDialogue) {
            setNpcs(prev => prev.map(npc => {
              let newNpc = { ...npc, moveTimer: npc.moveTimer + 1, thoughtTimer: npc.thoughtTimer + 1 };
              if (npc.clothesBlink > 0) {
                newNpc.clothesBlink = npc.clothesBlink - 0.1;
                if (newNpc.clothesBlink <= 0) { newNpc.clothesBlink = 0; newNpc.hasClothes = true; }
              }
              if (newNpc.thoughtTimer > 150) { newNpc.currentThought = (npc.currentThought + 1) % npc.thoughts.length; newNpc.thoughtTimer = 0; }
              if (npc.id === 'chavvah') {
                if (gamePhase === PHASES.CHAVVAH_WALKS_TO_TREE) {
                  newNpc.behavior = 'scene'; newNpc.targetX = TREE_OF_KNOWLEDGE.x + 1; newNpc.targetY = TREE_OF_KNOWLEDGE.y + 1;
                  if (Math.abs(npc.x - (TREE_OF_KNOWLEDGE.x + 1)) < 0.3 && Math.abs(npc.y - (TREE_OF_KNOWLEDGE.y + 1)) < 0.3) {
                    setGamePhase(PHASES.CHAVVAH_TAKES_FRUIT);
                    setSceneText("And a tree to be desired to make one wise...");
                    setShowSceneText(true);
                  }
                } else if (gamePhase === PHASES.CHAVVAH_WALKS_TO_ADAM) {
                  const adam = prev.find(n => n.id === 'adam');
                  if (adam) {
                    newNpc.targetX = adam.x - 1; newNpc.targetY = adam.y;
                    if (Math.abs(npc.x - (adam.x - 1)) < 0.5 && Math.abs(npc.y - adam.y) < 0.5) {
                      setGamePhase(PHASES.ADAM_EATS);
                      setSceneText("And gave also unto her husband with her; and he did eat...");
                      setShowSceneText(true);
                    }
                  }
                }
              }
              if (npc.id === 'adam' && gamePhase !== PHASES.EXPLORE) { newNpc.behavior = 'scene'; newNpc.targetX = null; newNpc.targetY = null; newNpc.isMoving = false; }
              if (npc.behavior === 'circle_tree') {
                newNpc.circleAngle = (npc.circleAngle || 0) + 0.02;
                const radius = 2.5;
                newNpc.targetX = TREE_OF_KNOWLEDGE.x + Math.cos(newNpc.circleAngle) * radius;
                newNpc.targetY = TREE_OF_KNOWLEDGE.y + Math.sin(newNpc.circleAngle) * radius;
              }
              if (npc.behavior === 'wander' && gamePhase === PHASES.EXPLORE && newNpc.moveTimer > 90) {
                if (!npc.targetX || (Math.abs(npc.x - npc.targetX) < 0.5 && Math.abs(npc.y - npc.targetY) < 0.5)) {
                  let attempts = 0, validTarget = false;
                  while (!validTarget && attempts < 10) {
                    const newTargetX = npc.homeX + (Math.random() - 0.5) * 8;
                    const newTargetY = npc.homeY + (Math.random() - 0.5) * 6;
                    if (canNPCMoveTo(newTargetX, newTargetY)) { newNpc.targetX = newTargetX; newNpc.targetY = newTargetY; validTarget = true; }
                    attempts++;
                  }
                  if (!validTarget) { newNpc.targetX = npc.homeX; newNpc.targetY = npc.homeY; }
                  newNpc.moveTimer = 0;
                }
              }
              if (npc.behavior === 'patrol' && npc.patrolPoints) {
                const target = npc.patrolPoints[npc.patrolIndex];
                if (Math.abs(npc.x - target.x) < 0.3 && Math.abs(npc.y - target.y) < 0.3) newNpc.patrolIndex = (npc.patrolIndex + 1) % npc.patrolPoints.length;
                newNpc.targetX = npc.patrolPoints[newNpc.patrolIndex].x;
                newNpc.targetY = npc.patrolPoints[newNpc.patrolIndex].y;
              }
              newNpc.prevX = npc.x; newNpc.prevY = npc.y;
              if (newNpc.targetX !== null && newNpc.targetY !== null) {
                const dx = newNpc.targetX - npc.x, dy = newNpc.targetY - npc.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0.1) {
                  const speed = (npc.id === 'chavvah' && gamePhase !== PHASES.EXPLORE) ? 0.04 : 0.03;
                  const moveX = npc.x + (dx / dist) * speed, moveY = npc.y + (dy / dist) * speed;

                  // Update direction based on movement
                  if (Math.abs(dx) > Math.abs(dy)) {
                    newNpc.direction = dx > 0 ? 'right' : 'left';
                  } else {
                    newNpc.direction = dy > 0 ? 'down' : 'up';
                  }

                  if (canNPCMoveTo(moveX, moveY) || npc.behavior === 'scene' || npc.behavior === 'circle_tree') {
                    newNpc.x = moveX; newNpc.y = moveY; newNpc.isMoving = true; newNpc.walkFrame = (npc.walkFrame + 0.25) % 4;
                  } else { newNpc.targetX = npc.homeX || npc.x; newNpc.targetY = npc.homeY || npc.y; newNpc.isMoving = false; newNpc.walkFrame = 0; }
                } else { newNpc.isMoving = false; newNpc.walkFrame = 0; }
              } else { newNpc.isMoving = false; newNpc.walkFrame = 0; }
              return newNpc;
            }));
          }
        }, 1000 / 30);
        return () => clearInterval(gameLoop);
      }, [canMoveTo, canNPCMoveTo, showDialogue, touchDirection, gameTime, gamePhase, checkSceneTrigger]);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');

        // Clear canvas
        ctx.fillStyle = '#1a3010';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw terrain
        for (let y = 0; y < VIEWPORT_HEIGHT + 1; y++) {
          for (let x = 0; x < VIEWPORT_WIDTH + 1; x++) {
            const mapX = Math.floor(camera.x) + x, mapY = Math.floor(camera.y) + y;
            if (mapX >= 0 && mapX < MAP_WIDTH && mapY >= 0 && mapY < MAP_HEIGHT) {
              const tile = map[mapY][mapX];
              const screenX = (x - (camera.x % 1)) * TILE_SIZE, screenY = (y - (camera.y % 1)) * TILE_SIZE;
              drawTerrain(ctx, screenX, screenY, tile, mapX, mapY, gameTime);
            }
          }
        }

        // Draw NPCs
        npcs.forEach(npc => {
          const screenX = (npc.x - camera.x) * TILE_SIZE - 4;
          const screenY = (npc.y - camera.y) * TILE_SIZE - 8;
          if (screenX > -TILE_SIZE * 2 && screenX < canvas.width + TILE_SIZE * 2 && screenY > -TILE_SIZE * 2 && screenY < canvas.height + TILE_SIZE * 2) {
            drawChibiCharacter(ctx, screenX, screenY, {
              ...npc,
              gameTime
            });

            // Draw thought bubble
            if (!showDialogue && gamePhase === PHASES.EXPLORE) {
              drawSpeechBubble(ctx, screenX + 12, screenY, npc.thoughts[npc.currentThought], npc.isSerpent);
            }

            // Draw name tag
            const nameText = npc.hasSpoken ? ` ${npc.name}` : npc.name;
            ctx.font = 'bold 9px monospace';
            const nameWidth = ctx.measureText(nameText).width + 8;

            // Name tag background
            ctx.fillStyle = npc.hasSpoken ? 'rgba(0, 100, 0, 0.9)' : 'rgba(0, 0, 0, 0.8)';
            ctx.strokeStyle = npc.hasSpoken ? '#4a4' : '#666';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(screenX + 12 - nameWidth / 2, screenY + 36, nameWidth, 14, 3);
            ctx.fill();
            ctx.stroke();

            // Name text
            ctx.fillStyle = npc.isSerpent ? '#90EE90' : '#fff';
            ctx.textAlign = 'center';
            ctx.fillText(nameText, screenX + 12, screenY + 47);
            ctx.textAlign = 'left';
          }
        });

        // Draw player
        if (gamePhase === PHASES.EXPLORE) {
          const playerScreenX = (player.x - camera.x) * TILE_SIZE - 4;
          const playerScreenY = (player.y - camera.y) * TILE_SIZE - 8;

          drawChibiCharacter(ctx, playerScreenX, playerScreenY, {
            skinColor: SKIN_COLOR,
            skinShadow: SKIN_SHADOW,
            hairColor: '#1a1a1a',
            hairHighlight: '#3a3a3a',
            outfitColor: '#3060a0',
            outfitShadow: '#204080',
            outfitHighlight: '#4080c0',
            direction: player.direction,
            walkFrame: player.walkFrame,
            isMoving: player.isMoving,
            gameTime
          });
        }

        // Camera follow during scenes
        if (gamePhase !== PHASES.EXPLORE && gamePhase !== PHASES.COMPLETE) {
          const chavvah = npcs.find(n => n.id === 'chavvah');
          if (chavvah) setCamera({ x: Math.max(0, Math.min(chavvah.x - VIEWPORT_WIDTH / 2, MAP_WIDTH - VIEWPORT_WIDTH)), y: Math.max(0, Math.min(chavvah.y - VIEWPORT_HEIGHT / 2, MAP_HEIGHT - VIEWPORT_HEIGHT)) });
        }
      }, [map, player, npcs, camera, showDialogue, gameTime, gamePhase]);

      const spokenCount = npcs.filter(n => ['adam', 'chavvah', 'nachash'].includes(n.id) && n.hasSpoken).length;

      return (
        <div className="game-container">
          <h1 className="title">BERE'SHIYTH: In The Beginning</h1>
          <canvas ref={canvasRef} width={VIEWPORT_WIDTH * TILE_SIZE} height={VIEWPORT_HEIGHT * TILE_SIZE} />

          {showDialogue && (
            <div className="dialogue-box">
              <div className="dialogue-header">
                <span className="dialogue-name">{showDialogue.name}</span>
                <span className="dialogue-counter">{showDialogue.currentDialogue + 1}/{npcs.find(n => n.id === showDialogue.id)?.dialogue.length}</span>
              </div>
              <p className="dialogue-text">{npcs.find(n => n.id === showDialogue.id)?.dialogue[showDialogue.currentDialogue]}</p>
              <button className="btn" onClick={advanceDialogue}>
                {showDialogue.currentDialogue < (npcs.find(n => n.id === showDialogue.id)?.dialogue.length || 1) - 1 ? 'Next ' : 'Close '}
              </button>
            </div>
          )}

          {showSceneText && !showDialogue && (
            <div className="dialogue-box">
              <p className="scene-text">{sceneText}</p>
              <button className="btn" onClick={() => { if (gamePhase !== PHASES.EXPLORE) advanceScene(); else setShowSceneText(false); }}>
                {gamePhase === PHASES.EXPLORE ? 'Begin ' : 'Continue '}
              </button>
            </div>
          )}

          {gamePhase === PHASES.EXPLORE && !showDialogue && !showSceneText && (
            <p className="quest-text">Speak to A'dam, Chavvah, and the Nachash ({spokenCount}/3)</p>
          )}

          {gamePhase === PHASES.EXPLORE && !showDialogue && !showSceneText && (
            <div className="controls">
              <div className="dpad">
                <div></div>
                <button className="dpad-btn" onTouchStart={(e) => { e.preventDefault(); handleTouchStart('up'); }} onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }} onMouseDown={() => handleTouchStart('up')} onMouseUp={handleTouchEnd} onMouseLeave={handleTouchEnd}></button>
                <div></div>
                <button className="dpad-btn" onTouchStart={(e) => { e.preventDefault(); handleTouchStart('left'); }} onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }} onMouseDown={() => handleTouchStart('left')} onMouseUp={handleTouchEnd} onMouseLeave={handleTouchEnd}></button>
                <div></div>
                <button className="dpad-btn" onTouchStart={(e) => { e.preventDefault(); handleTouchStart('right'); }} onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }} onMouseDown={() => handleTouchStart('right')} onMouseUp={handleTouchEnd} onMouseLeave={handleTouchEnd}></button>
                <div></div>
                <button className="dpad-btn" onTouchStart={(e) => { e.preventDefault(); handleTouchStart('down'); }} onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }} onMouseDown={() => handleTouchStart('down')} onMouseUp={handleTouchEnd} onMouseLeave={handleTouchEnd}></button>
                <div></div>
              </div>
              <button className="talk-btn" onClick={handleInteraction}>TALK</button>
            </div>
          )}

          {gamePhase !== PHASES.EXPLORE && (
            <p className="phase-indicator">{gamePhase === PHASES.COMPLETE ? ' The Fall of Man' : ' Scene in Progress...'}</p>
          )}

          <p className="help-text">WASD/Arrows to move  SPACE to interact</p>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<GenesisGame />);
  </script>
</body>
</html>
