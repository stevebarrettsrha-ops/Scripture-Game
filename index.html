<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>BERE'SHIYTH: In The Beginning</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #111827;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      -webkit-user-select: none;
      user-select: none;
      touch-action: manipulation;
    }
    #root { width: 100%; height: 100vh; }
    /* Canvas fills the whole screen; all UI floats on top */
    .game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    /* ── overlaid UI ─────────────────────────────────────── */
    .title {
      position: absolute;
      top: 8px; left: 50%; transform: translateX(-50%);
      font-size: 1rem;
      font-weight: bold;
      color: #facc15;
      font-family: Georgia, serif;
      text-shadow: 0 1px 4px #000;
      pointer-events: none;
      white-space: nowrap;
      z-index: 10;
    }
    .dialogue-box {
      position: absolute;
      bottom: 90px; left: 50%; transform: translateX(-50%);
      width: calc(100% - 24px);
      max-width: 640px;
      background: rgba(0,0,0,0.92);
      border: 2px solid #eab308;
      border-radius: 8px;
      padding: 12px;
      z-index: 20;
    }
    .dialogue-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .dialogue-name { color: #facc15; font-weight: bold; }
    .dialogue-counter { color: #6b7280; font-size: 0.75rem; }
    .dialogue-text { color: white; font-size: 0.9rem; margin-bottom: 12px; }
    .scene-text {
      color: #fde047;
      font-size: 0.9rem;
      font-style: italic;
      margin-bottom: 12px;
      font-family: Georgia, serif;
    }
    .btn {
      width: 100%;
      background: #ca8a04;
      color: white;
      font-weight: bold;
      padding: 8px 16px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn:hover { background: #eab308; }
    .btn:active { background: #a16207; }
    .quest-text {
      position: absolute;
      top: 34px; left: 50%; transform: translateX(-50%);
      color: #fde047;
      font-size: 0.8rem;
      text-shadow: 0 1px 3px #000;
      pointer-events: none;
      white-space: nowrap;
      z-index: 10;
    }
    .controls {
      position: absolute;
      bottom: 14px; left: 50%; transform: translateX(-50%);
      display: flex;
      gap: 32px;
      align-items: center;
      z-index: 20;
    }
    .dpad {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 4px;
    }
    .dpad-btn {
      width: 56px;
      height: 56px;
      background: rgba(31,41,55,0.85);
      border: 2px solid #4b5563;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      color: #d1d5db;
      cursor: pointer;
    }
    .dpad-btn:active { background: #374151; border-color: #eab308; }
    .talk-btn {
      width: 72px;
      height: 72px;
      background: #ca8a04;
      border: 4px solid #facc15;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 0.85rem;
      cursor: pointer;
    }
    .talk-btn:active { background: #eab308; }
    .phase-indicator {
      position: absolute;
      bottom: 14px; left: 50%; transform: translateX(-50%);
      color: #f87171;
      font-size: 0.85rem;
      font-weight: bold;
      text-transform: uppercase;
      text-shadow: 0 1px 3px #000;
      z-index: 10;
    }
    .help-text {
      position: absolute;
      bottom: 4px; right: 8px;
      color: #4b5563;
      font-size: 0.65rem;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;

    const TILE_SIZE = 64;
    const SCALE = 2;            // sprite / decoration scale (= TILE_SIZE / 32)
    const MAP_WIDTH = 80;
    const MAP_HEIGHT = 60;
    // Viewport dims are computed dynamically each frame from the canvas client size
    // so they always match the actual displayed resolution (handles fullscreen, resize, etc.)
    const getVP = (canvas) => ({
      w: Math.ceil((canvas.clientWidth  || window.innerWidth)  / TILE_SIZE) + 2,
      h: Math.ceil((canvas.clientHeight || window.innerHeight) / TILE_SIZE) + 2,
    });

    const GARDEN_BOUNDS = { minX: 10, maxX: 70, minY: 10, maxY: 48 };
    const TREE_OF_KNOWLEDGE = { x: 20, y: 22 };
    const SKIN_COLOR = '#5D4037';

    const TILES = {
      GRASS: 0, WATER: 1, TREE: 2, FLOWER: 3, PATH: 4,
      TREE_OF_LIFE: 5, TREE_OF_KNOWLEDGE: 6, ROCK: 7, BUSH: 8, GOLDEN_GATE: 9,
    };

    const COLORS = {
      grass: '#5a8f3d', grassDark: '#4a7f2d', water: '#3d7aaf', waterLight: '#5d9acf',
      tree: '#2d5a1d', treeTrunk: '#8b4513', flower: '#ff69b4', flowerYellow: '#ffd700',
      path: '#c9a86c', rock: '#808080', bush: '#3d6f2d', treeOfLife: '#ffd700',
      treeOfKnowledge: '#8b0000', sky: '#87ceeb',
    };

    const generateMap = () => {
      const TOL = { x: 56, y: 20 };   // Tree of Life
      const TOK = TREE_OF_KNOWLEDGE;   // { x: 20, y: 22 }
      const map = [];
      for (let y = 0; y < MAP_HEIGHT; y++) {
        const row = [];
        for (let x = 0; x < MAP_WIDTH; x++) {
          // River
          if (y >= 46 && y <= 50) row.push(TILES.WATER);
          // Garden paths: vertical spine x=30, horizontal corridor y=26
          else if ((x === 30 && y >= 10 && y <= 45) || (y === 26 && x >= 14 && x <= 66)) row.push(TILES.PATH);
          // Dense tree border around the whole map
          else if (x < 6 || x > MAP_WIDTH - 7 || y < 6 || y > MAP_HEIGHT - 7) row.push(Math.random() > 0.25 ? TILES.TREE : TILES.GRASS);
          else {
            const rand = Math.random();
            if (rand < 0.04) row.push(TILES.TREE);
            else if (rand < 0.07) row.push(TILES.FLOWER);
            else if (rand < 0.09) row.push(TILES.BUSH);
            else if (rand < 0.10) row.push(TILES.ROCK);
            else row.push(TILES.GRASS);
          }
        }
        map.push(row);
      }
      map[TOL.y][TOL.x] = TILES.TREE_OF_LIFE;
      map[TOK.y][TOK.x] = TILES.TREE_OF_KNOWLEDGE;
      // ── Golden Gate + Eastern Path ────────────────────────────────────────
      const GATE = { x: 63, y: 26 };
      // Carve a visible PATH corridor east of the gate all the way to the map edge
      for (let x = GATE.x + 1; x < MAP_WIDTH; x++) map[GATE.y][x] = TILES.PATH;
      // Flanking tree walls N and S of the gate — player cannot walk around it
      for (let dx = -1; dx <= 3; dx++) {
        const nx = GATE.x + dx;
        if (map[GATE.y - 1] && map[GATE.y - 1][nx] !== undefined) map[GATE.y - 1][nx] = TILES.TREE;
        if (map[GATE.y + 1] && map[GATE.y + 1][nx] !== undefined) map[GATE.y + 1][nx] = TILES.TREE;
      }
      map[GATE.y][GATE.x] = TILES.GOLDEN_GATE;
      // ─────────────────────────────────────────────────────────────────────
      // Clear a walkable ring around each special tree
      for (let dy = -3; dy <= 3; dy++) {
        for (let dx = -3; dx <= 3; dx++) {
          if (map[TOL.y + dy] && map[TOL.y + dy][TOL.x + dx] !== undefined && map[TOL.y + dy][TOL.x + dx] !== TILES.TREE_OF_LIFE) map[TOL.y + dy][TOL.x + dx] = TILES.GRASS;
          if (map[TOK.y + dy] && map[TOK.y + dy][TOK.x + dx] !== undefined && map[TOK.y + dy][TOK.x + dx] !== TILES.TREE_OF_KNOWLEDGE) map[TOK.y + dy][TOK.x + dx] = TILES.GRASS;
        }
      }
      return map;
    };

    const createNPCs = () => [
      {
        id: 'adam', name: "A'dam", x: 38, y: 30, prevX: 38, prevY: 30, color: SKIN_COLOR, hairColor: '#1a1a1a',
        thoughts: ["YAHUAH formed me from the dust...", "I am to dress and keep this garden.", "She is bone of my bones..."],
        dialogue: ["Shalom, traveler. I am A'dam.", "YAHUAH ELOHIYM formed me of the dust of the ground.", "He breathed into my nostrils the breath of life.", "I became a living nephesh.", "YAHUAH put me in the Garden of Eden to dress it and keep it.", "Of every tree I may freely eat...", "But of the Ets HaDa'at Tov v'Ra, I shall not eat.", "For in the day I eat thereof, I shall surely die."],
        currentDialogue: 0, currentThought: 0, thoughtTimer: 0, behavior: 'wander', homeX: 38, homeY: 30, targetX: null, targetY: null, moveTimer: 0, walkFrame: 0, isMoving: false, direction: 'down', hasSpoken: false, holdingFruit: false, isEating: false, hasGlory: true, hasClothes: false, clothesBlink: 0,
      },
      {
        id: 'chavvah', name: 'Chavvah', x: 42, y: 30, prevX: 42, prevY: 30, color: SKIN_COLOR, hairColor: '#1a1a1a', isEve: true,
        thoughts: ["The garden is so beautiful...", "That tree... the fruit looks good...", "The nachash says we won't die..."],
        dialogue: ["I am Chavvah, the mother of all living.", "YAHUAH ELOHIYM caused a deep sleep upon A'dam.", "He took one of his ribs and made me.", "We may eat of the fruit of the trees of the garden.", "But of the tree in the midst of the garden...", "ELOHIYM has said, Ye shall not eat of it.", "Neither shall ye touch it, lest ye die.", "But the nachash says our eyes will be opened..."],
        currentDialogue: 0, currentThought: 0, thoughtTimer: 0, behavior: 'wander', homeX: 42, homeY: 30, targetX: null, targetY: null, moveTimer: 0, walkFrame: 0, isMoving: false, direction: 'down', hasSpoken: false, holdingFruit: false, isEating: false, hasGlory: true, hasClothes: false, clothesBlink: 0,
      },
      {
        id: 'nachash', name: 'Nachash', x: 20, y: 24, prevX: 20, prevY: 24, color: '#228b22', isSerpent: true,
        thoughts: ["Yea, hath ELOHIYM said...?", "Ye shall not surely die...", "Your eyes shall be opened..."],
        dialogue: ["Yea, hath ELOHIYM said...", "Ye shall not eat of every tree of the garden?", "Ye shall not surely die.", "For ELOHIYM knows that in the day ye eat thereof...", "Your eyes shall be opened.", "And ye shall be as elohiym...", "Knowing good and evil.", "Is the fruit not pleasant to the eyes?"],
        currentDialogue: 0, currentThought: 0, thoughtTimer: 0, behavior: 'circle_tree', circleAngle: 0, targetX: null, targetY: null, moveTimer: 0, walkFrame: 0, isMoving: false, direction: 'down', hasSpoken: false,
      },
      {
        id: 'malak', name: 'Malak', x: 61, y: 26, prevX: 61, prevY: 26, color: SKIN_COLOR, hairColor: '#1a1a1a', isAngel: true,
        thoughts: ["None may pass the Sha'ar Zahav!", "The flaming sword turns every way...", "I guard the eastern gate of Eden."],
        dialogue: ["Shalom. I am a malak of YAHUAH.", "I stand guard at the Sha'ar Zahav - the Golden Gate.", "None may pass through this gate without YAHUAH's word.", "Beyond lies the path out of the garden.", "YAHUAH set cherubim to guard the way.", "Turn back, child. The garden is your dwelling."],
        currentDialogue: 0, currentThought: 0, thoughtTimer: 0, behavior: 'patrol', patrolPoints: [{x: 61, y: 26}, {x: 59, y: 26}, {x: 61, y: 26}], patrolIndex: 0, targetX: null, targetY: null, moveTimer: 0, walkFrame: 0, isMoving: false, direction: 'right', hasSpoken: false,
      }
    ];

    const PHASES = {
      EXPLORE: 'explore', SCENE_START: 'scene_start', CHAVVAH_WALKS_TO_TREE: 'chavvah_walks',
      CHAVVAH_TAKES_FRUIT: 'chavvah_takes', CHAVVAH_EATS: 'chavvah_eats', CHAVVAH_GLORY_FADES: 'chavvah_glory_fades',
      CHAVVAH_WALKS_TO_ADAM: 'chavvah_to_adam', ADAM_EATS: 'adam_eats', ADAM_GLORY_FADES: 'adam_glory_fades',
      EYES_OPENED: 'eyes_opened', COMPLETE: 'complete'
    };

    const GenesisGame = () => {
      const canvasRef = useRef(null);
      const [map] = useState(generateMap);
      const [player, setPlayer] = useState({ x: 35, y: 30, prevX: 35, prevY: 30, direction: 'down', walkFrame: 0, isMoving: false });
      const [npcs, setNpcs] = useState(createNPCs);
      const [camera, setCamera] = useState({ x: 0, y: 0 });
      const [showDialogue, setShowDialogue] = useState(null);
      const [sceneText, setSceneText] = useState("Bere'shiyth - In the beginning ELOHIYM created the heavens and the earth...");
      const [showSceneText, setShowSceneText] = useState(true);
      const [gameTime, setGameTime] = useState(0);
      const [gamePhase, setGamePhase] = useState(PHASES.EXPLORE);
      const keysPressed = useRef({});
      const [touchDirection, setTouchDirection] = useState(null);

      const checkSceneTrigger = useCallback(() => {
        const adam = npcs.find(n => n.id === 'adam');
        const chavvah = npcs.find(n => n.id === 'chavvah');
        const nachash = npcs.find(n => n.id === 'nachash');
        return adam?.hasSpoken && chavvah?.hasSpoken && nachash?.hasSpoken;
      }, [npcs]);

      const canNPCMoveTo = useCallback((x, y) => {
        if (x < GARDEN_BOUNDS.minX || x > GARDEN_BOUNDS.maxX || y < GARDEN_BOUNDS.minY || y > GARDEN_BOUNDS.maxY) return false;
        if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return false;
        const tile = map[Math.floor(y)][Math.floor(x)];
        return tile === TILES.GRASS || tile === TILES.PATH;
      }, [map]);

      const canMoveTo = useCallback((x, y, currentNpcs) => {
        if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return false;
        const tile = map[Math.floor(y)][Math.floor(x)];
        if (tile !== TILES.GRASS && tile !== TILES.PATH) return false;
        // Block walking through NPCs
        if (currentNpcs) {
          for (const npc of currentNpcs) {
            if (Math.abs(x - npc.x) < 0.8 && Math.abs(y - npc.y) < 0.8) return false;
          }
        }
        return true;
      }, [map]);

      useEffect(() => {
        const vp = getVP(canvasRef.current || { clientWidth: window.innerWidth, clientHeight: window.innerHeight });
        setCamera({
          x: Math.max(0, Math.min(player.x - vp.w / 2, MAP_WIDTH - vp.w)),
          y: Math.max(0, Math.min(player.y - vp.h / 2, MAP_HEIGHT - vp.h))
        });
      }, [player]);

      const advanceDialogue = useCallback(() => {
        if (!showDialogue) return;
        const currentNpc = npcs.find(n => n.id === showDialogue.id);
        if (currentNpc) {
          const nextDialogue = showDialogue.currentDialogue + 1;
          if (nextDialogue >= currentNpc.dialogue.length) {
            setShowDialogue(null);
            setNpcs(prev => prev.map(npc => npc.id === currentNpc.id ? { ...npc, hasSpoken: true, currentDialogue: 0 } : npc));
          } else {
            setShowDialogue({ ...showDialogue, currentDialogue: nextDialogue });
          }
        }
      }, [showDialogue, npcs]);

      const handleInteraction = useCallback(() => {
        if (showDialogue) { advanceDialogue(); return; }
        if (showSceneText) { setShowSceneText(false); return; }
        if (gamePhase === PHASES.EXPLORE) {
          const nearbyNpc = npcs.find(npc => Math.abs(npc.x - player.x) < 1.5 && Math.abs(npc.y - player.y) < 1.5);
          if (nearbyNpc) setShowDialogue({ ...nearbyNpc, currentDialogue: 0 });
        }
      }, [showDialogue, showSceneText, gamePhase, npcs, player, advanceDialogue]);

      const advanceScene = useCallback(() => {
        setShowSceneText(false);
        switch (gamePhase) {
          case PHASES.SCENE_START:
            setGamePhase(PHASES.CHAVVAH_WALKS_TO_TREE);
            setSceneText("And when the woman saw that the tree was good for food, and pleasant to the eyes...");
            setShowSceneText(true);
            break;
          case PHASES.CHAVVAH_TAKES_FRUIT:
            setNpcs(prev => prev.map(npc => npc.id === 'chavvah' ? { ...npc, holdingFruit: true } : npc));
            setGamePhase(PHASES.CHAVVAH_EATS);
            setSceneText("She took of the fruit thereof...");
            setShowSceneText(true);
            break;
          case PHASES.CHAVVAH_EATS:
            setNpcs(prev => prev.map(npc => npc.id === 'chavvah' ? { ...npc, isEating: true } : npc));
            setTimeout(() => {
              setNpcs(prev => prev.map(npc => npc.id === 'chavvah' ? { ...npc, isEating: false } : npc));
              setGamePhase(PHASES.CHAVVAH_GLORY_FADES);
              setSceneText("And did eat... and the glory of YAHUAH departed from her...");
              setShowSceneText(true);
              setTimeout(() => {
                setNpcs(prev => prev.map(npc => npc.id === 'chavvah' ? { ...npc, hasGlory: false, clothesBlink: 4 } : npc));
              }, 500);
            }, 1500);
            break;
          case PHASES.CHAVVAH_GLORY_FADES:
            setGamePhase(PHASES.CHAVVAH_WALKS_TO_ADAM);
            setSceneText("And gave also unto her husband with her...");
            setShowSceneText(true);
            break;
          case PHASES.ADAM_EATS:
            setNpcs(prev => prev.map(npc => npc.id === 'adam' ? { ...npc, holdingFruit: true, isEating: true } : npc));
            setTimeout(() => {
              setNpcs(prev => prev.map(npc => npc.id === 'adam' ? { ...npc, isEating: false } : npc));
              setGamePhase(PHASES.ADAM_GLORY_FADES);
              setSceneText("And he did eat... and the glory departed from him also...");
              setShowSceneText(true);
              setTimeout(() => {
                setNpcs(prev => prev.map(npc => npc.id === 'adam' ? { ...npc, hasGlory: false, clothesBlink: 4 } : npc));
              }, 500);
            }, 1500);
            break;
          case PHASES.ADAM_GLORY_FADES:
            setGamePhase(PHASES.EYES_OPENED);
            setSceneText("And the eyes of them both were opened, and they knew that they were naked...");
            setShowSceneText(true);
            break;
          case PHASES.EYES_OPENED:
            setGamePhase(PHASES.COMPLETE);
            setSceneText("And they sewed fig leaves together, and made themselves aprons...");
            setShowSceneText(true);
            break;
        }
      }, [gamePhase]);

      useEffect(() => {
        const handleKeyDown = (e) => {
          keysPressed.current[e.key.toLowerCase()] = true;
          if (e.key === ' ' || e.key === 'Enter') {
            e.preventDefault();
            if (showSceneText && gamePhase !== PHASES.EXPLORE) advanceScene();
            else handleInteraction();
          }
        };
        const handleKeyUp = (e) => { keysPressed.current[e.key.toLowerCase()] = false; };
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        return () => { window.removeEventListener('keydown', handleKeyDown); window.removeEventListener('keyup', handleKeyUp); };
      }, [handleInteraction, advanceScene, showSceneText, gamePhase]);

      const handleTouchStart = (direction) => setTouchDirection(direction);
      const handleTouchEnd = () => setTouchDirection(null);

      useEffect(() => {
        const gameLoop = setInterval(() => {
          setGameTime(prev => prev + 1);
          if (gamePhase === PHASES.EXPLORE && checkSceneTrigger()) {
            setGamePhase(PHASES.SCENE_START);
            setSceneText("The nachash beguiled Chavvah... she looked upon the forbidden tree...");
            setShowSceneText(true);
          }
          if (!showDialogue && gamePhase === PHASES.EXPLORE) {
            setPlayer(prev => {
              let newX = prev.x, newY = prev.y, newDir = prev.direction;
              const speed = 0.15;
              const up = keysPressed.current['w'] || keysPressed.current['arrowup'] || touchDirection === 'up';
              const down = keysPressed.current['s'] || keysPressed.current['arrowdown'] || touchDirection === 'down';
              const left = keysPressed.current['a'] || keysPressed.current['arrowleft'] || touchDirection === 'left';
              const right = keysPressed.current['d'] || keysPressed.current['arrowright'] || touchDirection === 'right';
              if (up) { newY -= speed; newDir = 'up'; }
              if (down) { newY += speed; newDir = 'down'; }
              if (left) { newX -= speed; newDir = 'left'; }
              if (right) { newX += speed; newDir = 'right'; }
              let finalX = prev.x, finalY = prev.y;
              if (canMoveTo(newX, newY, npcs)) { finalX = newX; finalY = newY; }
              else if (canMoveTo(newX, prev.y, npcs)) { finalX = newX; }
              else if (canMoveTo(prev.x, newY, npcs)) { finalY = newY; }
              const isMoving = finalX !== prev.x || finalY !== prev.y;
              const walkFrame = isMoving ? (prev.walkFrame + 0.3) % 4 : 0;
              return { x: finalX, y: finalY, prevX: prev.x, prevY: prev.y, direction: newDir, walkFrame, isMoving };
            });
          }
          if (!showDialogue) {
            setNpcs(prev => prev.map(npc => {
              let newNpc = { ...npc, moveTimer: npc.moveTimer + 1, thoughtTimer: npc.thoughtTimer + 1 };
              if (npc.clothesBlink > 0) {
                newNpc.clothesBlink = npc.clothesBlink - 0.1;
                if (newNpc.clothesBlink <= 0) { newNpc.clothesBlink = 0; newNpc.hasClothes = true; }
              }
              if (newNpc.thoughtTimer > 150) { newNpc.currentThought = (npc.currentThought + 1) % npc.thoughts.length; newNpc.thoughtTimer = 0; }
              if (npc.id === 'chavvah') {
                if (gamePhase === PHASES.CHAVVAH_WALKS_TO_TREE) {
                  newNpc.behavior = 'scene'; newNpc.targetX = TREE_OF_KNOWLEDGE.x + 1; newNpc.targetY = TREE_OF_KNOWLEDGE.y + 1;
                  if (Math.abs(npc.x - (TREE_OF_KNOWLEDGE.x + 1)) < 0.3 && Math.abs(npc.y - (TREE_OF_KNOWLEDGE.y + 1)) < 0.3) {
                    setGamePhase(PHASES.CHAVVAH_TAKES_FRUIT);
                    setSceneText("And a tree to be desired to make one wise...");
                    setShowSceneText(true);
                  }
                } else if (gamePhase === PHASES.CHAVVAH_WALKS_TO_ADAM) {
                  const adam = prev.find(n => n.id === 'adam');
                  if (adam) {
                    newNpc.targetX = adam.x - 1; newNpc.targetY = adam.y;
                    if (Math.abs(npc.x - (adam.x - 1)) < 0.5 && Math.abs(npc.y - adam.y) < 0.5) {
                      setGamePhase(PHASES.ADAM_EATS);
                      setSceneText("And gave also unto her husband with her; and he did eat...");
                      setShowSceneText(true);
                    }
                  }
                }
              }
              if (npc.id === 'adam' && gamePhase !== PHASES.EXPLORE) { newNpc.behavior = 'scene'; newNpc.targetX = null; newNpc.targetY = null; newNpc.isMoving = false; }
              if (npc.behavior === 'circle_tree') {
                newNpc.circleAngle = (npc.circleAngle || 0) + 0.02;
                const radius = 2.5;
                newNpc.targetX = TREE_OF_KNOWLEDGE.x + Math.cos(newNpc.circleAngle) * radius;
                newNpc.targetY = TREE_OF_KNOWLEDGE.y + Math.sin(newNpc.circleAngle) * radius;
              }
              if (npc.behavior === 'wander' && gamePhase === PHASES.EXPLORE && newNpc.moveTimer > 90) {
                if (!npc.targetX || (Math.abs(npc.x - npc.targetX) < 0.5 && Math.abs(npc.y - npc.targetY) < 0.5)) {
                  let attempts = 0, validTarget = false;
                  while (!validTarget && attempts < 10) {
                    const newTargetX = npc.homeX + (Math.random() - 0.5) * 8;
                    const newTargetY = npc.homeY + (Math.random() - 0.5) * 6;
                    if (canNPCMoveTo(newTargetX, newTargetY)) { newNpc.targetX = newTargetX; newNpc.targetY = newTargetY; validTarget = true; }
                    attempts++;
                  }
                  if (!validTarget) { newNpc.targetX = npc.homeX; newNpc.targetY = npc.homeY; }
                  newNpc.moveTimer = 0;
                }
              }
              if (npc.behavior === 'patrol' && npc.patrolPoints) {
                const target = npc.patrolPoints[npc.patrolIndex];
                if (Math.abs(npc.x - target.x) < 0.3 && Math.abs(npc.y - target.y) < 0.3) newNpc.patrolIndex = (npc.patrolIndex + 1) % npc.patrolPoints.length;
                newNpc.targetX = npc.patrolPoints[newNpc.patrolIndex].x;
                newNpc.targetY = npc.patrolPoints[newNpc.patrolIndex].y;
              }
              newNpc.prevX = npc.x; newNpc.prevY = npc.y;
              if (newNpc.targetX !== null && newNpc.targetY !== null) {
                const dx = newNpc.targetX - npc.x, dy = newNpc.targetY - npc.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0.1) {
                  const speed = (npc.id === 'chavvah' && gamePhase !== PHASES.EXPLORE) ? 0.04 : 0.03;
                  const moveX = npc.x + (dx / dist) * speed, moveY = npc.y + (dy / dist) * speed;
                  if (canNPCMoveTo(moveX, moveY) || npc.behavior === 'scene' || npc.behavior === 'circle_tree') {
                    newNpc.x = moveX; newNpc.y = moveY; newNpc.isMoving = true; newNpc.walkFrame = (npc.walkFrame + 0.25) % 4;
                    newNpc.direction = Math.abs(dx) >= Math.abs(dy) ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'down' : 'up');
                  } else { newNpc.targetX = npc.homeX || npc.x; newNpc.targetY = npc.homeY || npc.y; newNpc.isMoving = false; newNpc.walkFrame = 0; }
                } else { newNpc.isMoving = false; newNpc.walkFrame = 0; }
              } else { newNpc.isMoving = false; newNpc.walkFrame = 0; }
              return newNpc;
            }));
          }
        }, 1000 / 30);
        return () => clearInterval(gameLoop);
      }, [canMoveTo, canNPCMoveTo, showDialogue, touchDirection, gameTime, gamePhase, checkSceneTrigger]);

      const drawSpeechBubble = (ctx, x, y, text, isSerpent = false) => {
        const FONT = 'bold 14px sans-serif';
        const maxWidth = 240, padding = 11, lineHeight = 20;
        ctx.font = FONT;
        const words = text.split(' ');
        const lines = [];
        let currentLine = '';
        words.forEach(word => {
          const testLine = currentLine + (currentLine ? ' ' : '') + word;
          if (ctx.measureText(testLine).width > maxWidth - padding * 2) { if (currentLine) lines.push(currentLine); currentLine = word; }
          else currentLine = testLine;
        });
        if (currentLine) lines.push(currentLine);
        const bubbleWidth = Math.min(maxWidth, Math.max(...lines.map(l => ctx.measureText(l).width)) + padding * 2);
        const bubbleHeight = lines.length * lineHeight + padding * 2;
        const bubbleX = x - bubbleWidth / 2, bubbleY = y - bubbleHeight - 26;
        ctx.fillStyle = isSerpent ? 'rgba(20, 40, 20, 0.96)' : 'rgba(255, 255, 255, 0.96)';
        ctx.strokeStyle = isSerpent ? '#5a9c5a' : '#444';
        ctx.lineWidth = 2;
        const radius = 10;
        ctx.beginPath();
        ctx.moveTo(bubbleX + radius, bubbleY);
        ctx.lineTo(bubbleX + bubbleWidth - radius, bubbleY);
        ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY, bubbleX + bubbleWidth, bubbleY + radius);
        ctx.lineTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight - radius);
        ctx.quadraticCurveTo(bubbleX + bubbleWidth, bubbleY + bubbleHeight, bubbleX + bubbleWidth - radius, bubbleY + bubbleHeight);
        ctx.lineTo(bubbleX + radius, bubbleY + bubbleHeight);
        ctx.quadraticCurveTo(bubbleX, bubbleY + bubbleHeight, bubbleX, bubbleY + bubbleHeight - radius);
        ctx.lineTo(bubbleX, bubbleY + radius);
        ctx.quadraticCurveTo(bubbleX, bubbleY, bubbleX + radius, bubbleY);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = isSerpent ? 'rgba(20, 40, 20, 0.96)' : 'rgba(255, 255, 255, 0.96)';
        ctx.beginPath(); ctx.arc(x - 5, bubbleY + bubbleHeight + 6, 5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.arc(x - 1, bubbleY + bubbleHeight + 14, 3, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = isSerpent ? '#aaffaa' : '#111';
        ctx.font = FONT;
        lines.forEach((line, i) => { ctx.fillText(line, bubbleX + padding, bubbleY + padding + lineHeight * (i + 0.85)); });
      };

      // Pokemon Generation III TDSM-style sprite renderer.
      // Chibi proportions: big head (~13 px, ~50 % of height), short body (7 px),
      // short chunky legs (7 px + 2 px shoe).  Dark pixel outline on every part.
      // All coordinates are anchored to cx (tile centre) so the sprite is always
      // perfectly symmetric and nothing ever detaches.
      //
      // Layout (by = screenY + bob):
      //   HEAD  : by+ 0 … by+13   (hair fills top half, face bottom half)
      //   BODY  : by+13 … by+20
      //   ARMS  : by+13 … by+20   (2 px wide, outside body)
      //   LEGS  : by+20 … by+27
      //   SHOES : by+26 … by+28
      const drawCharacterSprite = (ctx, screenX, screenY, opts) => {
        const {
          walkFrame = 0, isMoving = false, direction = 'down',
          hairColor = '#1a1a1a', bodyColor = '#4169e1', skinColor = SKIN_COLOR,
          isEve = false, showClothes = false,
          holdingFruit = false, isEating = false, hasGlory = false, gameTime = 0,
        } = opts;

        const frame = Math.floor(walkFrame) % 4;
        const bob   = isMoving && frame % 2 === 1 ? 1 : 0;
        const cx    = screenX + 16;   // horizontal centre – never drifts
        const by    = screenY + bob;  // head top

        // r(dx,dy,w,h,color) – fill a rect relative to cx / by
        const r = (dx, dy, w, h, c) => { ctx.fillStyle = c; ctx.fillRect(cx + dx, by + dy, w, h); };

        const DK   = '#0d0700';                              // dark pixel outline
        const SH   = '#17100a';                              // shoe colour
        const bClr = showClothes ? '#8b7355' : bodyColor;   // shirt / torso

        // ── GLORY AURA ────────────────────────────────────────────
        if (hasGlory) {
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur  = 12 + Math.sin(gameTime * 0.15) * 4;
          ctx.fillStyle   = 'rgba(255,215,0,0.22)';
          ctx.beginPath();
          ctx.ellipse(cx, by + 14, 13, 16, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }

        const isSide = direction === 'left' || direction === 'right';

        // ── LEGS  (tops ALWAYS at by+20 = body bottom; never detach) ─────
        if (isSide) {
          // Side profile: wider leg implies two overlapping legs in profile.
          // Two shoes swing in opposite phase to mimic a two-footed stride.
          const dir = direction === 'right' ? 1 : -1;
          const fStep = !isMoving ? 0 : frame === 1 ?  2*dir : frame === 3 ? -2*dir : 0;
          const bStep = !isMoving ? 0 : frame === 1 ? -2*dir : frame === 3 ?  2*dir : 0;
          r(-3, 20, 6, 6, bClr);               // wider leg (two legs overlapping in profile)
          r(-4 + bStep, 26, 7, 2, bClr);       // back shoe (body colour = depth cue)
          r(-4 + fStep, 26, 7, 2, SH);         // front shoe swings forward / back
        } else if (!isMoving) {
          r(-5, 20, 4, 6, bClr);  r(-6, 26, 6, 2, SH);  // left
          r( 1, 20, 4, 6, bClr);  r( 0, 26, 6, 2, SH);  // right
        } else {
          // Front / back view: alternate which leg strides
          const fwdX = frame < 2 ? -5 :  1;
          const bckX = frame < 2 ?  1 : -5;
          r(bckX, 20, 4, 4, bClr);  r(bckX - 1, 24, 5, 2, SH);  // back (shorter)
          r(fwdX, 20, 4, 6, bClr);  r(fwdX - 1, 26, 6, 2, SH);  // forward (full)
        }

        // ── BODY  (by+13 … by+20) ─────────────────────────────────
        r(-6, 12, 12, 9, DK);     // outline
        r(-5, 13, 10, 7, bClr);   // fill

        // ── ARMS ──────────────────────────────────────────────────
        if (isSide) {
          // Side profile: single arm centered on body, swings with walk
          const aSwg = isMoving ? (frame < 2 ? 2 : -2) : 0;
          r(-2, 13 + aSwg, 4, 8, DK);          // outline
          r(-1, 14 + aSwg, 2, 6, skinColor);    // skin fill
        } else {
          // Front / back: two arms on opposite sides, swing in counter-phase
          const armSwg = isMoving ? (frame < 2 ? 2 : -2) : 0;
          r(-8, 13 + armSwg, 3, 7, DK);  r(-8, 14 + armSwg, 2, 5, skinColor);  // left
          r( 5, 13 - armSwg, 3, 7, DK);  r( 5, 14 - armSwg, 2, 5, skinColor);  // right
        }

        // ── HEAD  (by+0 … by+13) ──────────────────────────────────
        // Gen III chibi: head ≈ 50 % of total height.
        // Dark outline box → base skin → hair overlay → eyes on top.

        r(-7, 0, 14, 14, DK);          // dark outline (1 px border)
        r(-6, 1, 12, 12, skinColor);   // base skin fill

        // HAIR – direction specific
        if (direction === 'up') {
          r(-6, 1, 12, 12, hairColor); // back-of-head: all hair
        } else if (direction === 'left') {
          r(-6, 1, 12, 7, hairColor);  // top hair band (generous, Gen III style)
          r( 3, 1,  3, 12, hairColor); // right-side hair visible in left profile
        } else if (direction === 'right') {
          r(-6, 1, 12, 7, hairColor);
          r(-6, 1,  3, 12, hairColor); // left-side hair visible in right profile
        } else {
          r(-6, 1, 12, 7, hairColor);  // facing down: thick top band (covers ~60 % of head)
        }

        // Chavvah / Eve: long flowing side strands (outside head outline)
        if (isEve && direction !== 'up') {
          r(-9, 5, 3, 10, hairColor);
          r( 6, 5, 3, 10, hairColor);
        }

        // EYES – two when facing down, one when facing sideways, none when facing up
        if (direction !== 'up') {
          if (direction !== 'left') {   // right eye (visible facing down or right)
            r( 1, 9, 3, 3, '#f0f0f0');
            r( 2, 10, 2, 2, DK);
          }
          if (direction !== 'right') {  // left eye (visible facing down or left)
            r(-4, 9, 3, 3, '#f0f0f0');
            r(-4, 10, 2, 2, DK);
          }
        }

        // Eating indicator
        if (isEating) { r(-2, 11, 4, 2, '#8b0000'); }

        // Held fruit (held to the right of body)
        if (holdingFruit && !isEating) {
          ctx.fillStyle = '#cc0000';
          ctx.beginPath(); ctx.arc(cx + 10, by + 17, 4, 0, Math.PI * 2); ctx.fill();
          r(8, 13, 2, 4, '#654321'); // stem
        }
      };

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        // Account for device pixel ratio so canvas text and graphics are
        // crisp on Retina / high-DPI screens.  All coordinates below stay
        // in CSS pixels; only the bitmap is larger.
        const dpr = window.devicePixelRatio || 1;
        const W = canvas.clientWidth  || window.innerWidth;
        const H = canvas.clientHeight || window.innerHeight;
        if (canvas.width  !== Math.round(W * dpr)) canvas.width  = Math.round(W * dpr);
        if (canvas.height !== Math.round(H * dpr)) canvas.height = Math.round(H * dpr);
        const vp = { w: Math.ceil(W / TILE_SIZE) + 2, h: Math.ceil(H / TILE_SIZE) + 2 };
        const ctx = canvas.getContext('2d');
        // Reset transform then apply DPR scale so every draw call uses CSS px.
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.fillStyle = COLORS.sky;
        ctx.fillRect(0, 0, W, H);

        // ── PASS 1: Ground layer (flat tiles) ─────────────────────────────
        const tallObjects = [];
        for (let y = 0; y < vp.h + 1; y++) {
          for (let x = 0; x < vp.w + 1; x++) {
            const mapX = Math.floor(camera.x) + x, mapY = Math.floor(camera.y) + y;
            if (mapX >= 0 && mapX < MAP_WIDTH && mapY >= 0 && mapY < MAP_HEIGHT) {
              const tile = map[mapY][mapX];
              const screenX = (x - (camera.x % 1)) * TILE_SIZE, screenY = (y - (camera.y % 1)) * TILE_SIZE;

              // ── Natural grass base ─────────────────
              const gh = ((mapX * 1234567 + mapY * 891011) >>> 0) % 100;
              const grassBases = ['#4e7c2b', '#527f2e', '#4a7828', '#568231', '#4c7a2c'];
              ctx.fillStyle = grassBases[gh % 5];
              ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);

              // Grass details only where grass is visible (skip water/path)
              if (tile !== TILES.WATER && tile !== TILES.PATH && tile !== TILES.GOLDEN_GATE) {
                if (gh < 18) {
                  ctx.fillStyle = 'rgba(90,62,28,0.18)';
                  ctx.fillRect(screenX + (gh * 5) % 44, screenY + (gh * 7) % 44, 14, 12);
                }
                ctx.fillStyle = '#3a6020';
                for (let bi = 0; bi < 5; bi++) {
                  ctx.fillRect(screenX + (gh*(bi+1)*13+mapX)%58+2, screenY + (gh*(bi+1)*7+mapY)%56+2, 2, 5);
                }
                ctx.fillStyle = '#6aaa3e';
                for (let bi = 0; bi < 3; bi++) {
                  ctx.fillRect(screenX + (gh*(bi+4)*17)%58+2, screenY + (gh*(bi+4)*11)%56+2, 2, 3);
                }
              }

              switch (tile) {
                case TILES.WATER:
                  ctx.fillStyle = (gameTime + mapX + mapY) % 20 < 10 ? COLORS.water : COLORS.waterLight;
                  ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                  ctx.fillStyle = 'rgba(255,255,255,0.12)';
                  ctx.fillRect(screenX + ((gameTime + mapX*3)%48)+4, screenY + ((gameTime*2+mapY*5)%48)+4, 18, 4);
                  break;
                case TILES.FLOWER:
                  ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
                  ctx.fillStyle = mapX % 2 === 0 ? COLORS.flower : COLORS.flowerYellow;
                  ctx.beginPath(); ctx.arc(16, 18, 5, 0, Math.PI * 2); ctx.fill();
                  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(16, 18, 2, 0, Math.PI * 2); ctx.fill();
                  ctx.restore();
                  break;
                case TILES.PATH: {
                  const ph = ((mapX * 2345 + mapY * 6789) >>> 0) % 100;
                  ctx.fillStyle = '#9b7d52';
                  ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                  ctx.fillStyle = '#7a6040';
                  for (let pi = 0; pi < 4; pi++) ctx.fillRect(screenX + (ph*(pi+1)*11)%56+4, screenY + (ph*(pi+1)*7)%56+4, 5, 3);
                  ctx.fillStyle = '#c0a070';
                  for (let pi = 0; pi < 3; pi++) ctx.fillRect(screenX + (ph*(pi+4)*17)%56+4, screenY + (ph*(pi+4)*13)%56+4, 3, 2);
                  break;
                }
                case TILES.ROCK:
                  ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
                  ctx.fillStyle = COLORS.rock; ctx.beginPath(); ctx.ellipse(16, 20, 10, 8, 0, 0, Math.PI * 2); ctx.fill();
                  ctx.restore();
                  break;
                case TILES.BUSH:
                  ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
                  ctx.fillStyle = COLORS.bush; ctx.beginPath(); ctx.arc(16, 20, 10, 0, Math.PI * 2); ctx.fill();
                  ctx.restore();
                  break;
                case TILES.GOLDEN_GATE:
                  // Path ground under the gate (drawn in pass 1)
                  ctx.fillStyle = '#9b7d52'; ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);
                  tallObjects.push({ tile, screenX, screenY });
                  break;
                case TILES.TREE:
                case TILES.TREE_OF_LIFE:
                case TILES.TREE_OF_KNOWLEDGE:
                  // Defer to pass 2 so they draw on top of all ground
                  tallObjects.push({ tile, screenX, screenY, mapX });
                  break;
              }
            }
          }
        }

        // ── PASS 2: Tall objects (trees, gate) drawn over all ground ──────
        tallObjects.forEach(({ tile, screenX, screenY, mapX }) => {
          switch (tile) {
            case TILES.TREE:
              ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
              ctx.fillStyle = COLORS.treeTrunk; ctx.fillRect(12, 16, 8, 16);
              ctx.fillStyle = COLORS.tree; ctx.beginPath(); ctx.arc(16, 12, 14, 0, Math.PI * 2); ctx.fill();
              ctx.fillStyle = 'rgba(255,255,255,0.10)';
              ctx.beginPath(); ctx.arc(13, 8, 7, 0, Math.PI * 2); ctx.fill();
              ctx.restore();
              break;
            case TILES.TREE_OF_LIFE:
              ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
              ctx.fillStyle = '#654321'; ctx.fillRect(8, 10, 16, 22);
              ctx.fillStyle = COLORS.treeOfLife; ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 20 + Math.sin(gameTime * 0.1) * 8;
              ctx.beginPath(); ctx.arc(16, 4, 22, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
              ctx.fillStyle = '#ffd700'; ctx.font = 'bold 7px monospace'; ctx.textAlign = 'center';
              ctx.fillText('ETS CHAYIM', 16, 30); ctx.textAlign = 'left';
              ctx.restore();
              break;
            case TILES.TREE_OF_KNOWLEDGE:
              ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
              ctx.fillStyle = '#4a3520'; ctx.fillRect(8, 10, 16, 22);
              ctx.fillStyle = '#1a3a1a'; ctx.beginPath(); ctx.arc(16, 4, 22, 0, Math.PI * 2); ctx.fill();
              ctx.fillStyle = '#cc0000';
              [[8,2],[24,0],[16,8],[6,10],[26,8]].forEach(([fx,fy]) => { ctx.beginPath(); ctx.arc(fx, fy, 4, 0, Math.PI * 2); ctx.fill(); });
              ctx.fillStyle = '#ff6666'; ctx.font = 'bold 6px monospace'; ctx.textAlign = 'center';
              ctx.fillText("ETS HADA'AT", 16, 30);
              ctx.fillText("TOV V'RA", 16, 37); ctx.textAlign = 'left';
              ctx.restore();
              break;
            case TILES.GOLDEN_GATE: {
              ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
              const glowPulse = 0.5 + 0.5 * Math.sin(gameTime * 0.07);
              ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 18 + glowPulse * 12;
              const pillarGrad = ctx.createLinearGradient(4, 0, 10, 0);
              pillarGrad.addColorStop(0, '#8b6914'); pillarGrad.addColorStop(0.3, '#ffd700'); pillarGrad.addColorStop(0.7, '#ffec6e'); pillarGrad.addColorStop(1, '#b8860b');
              ctx.fillStyle = pillarGrad; ctx.fillRect(4, -26, 6, 58);
              const pillarGrad2 = ctx.createLinearGradient(22, 0, 28, 0);
              pillarGrad2.addColorStop(0, '#b8860b'); pillarGrad2.addColorStop(0.3, '#ffec6e'); pillarGrad2.addColorStop(0.7, '#ffd700'); pillarGrad2.addColorStop(1, '#8b6914');
              ctx.fillStyle = pillarGrad2; ctx.fillRect(22, -26, 6, 58);
              ctx.fillStyle = '#ffd700';
              ctx.fillRect(2, -29, 10, 4); ctx.fillRect(20, -29, 10, 4);
              ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 4;
              ctx.beginPath(); ctx.arc(16, -26, 12, Math.PI, 0); ctx.stroke();
              ctx.lineWidth = 2; ctx.strokeStyle = '#fff8dc';
              ctx.beginPath(); ctx.arc(16, -26, 10, Math.PI, 0); ctx.stroke();
              ctx.strokeStyle = '#daa520'; ctx.lineWidth = 1.5;
              for (let bx = 11; bx <= 21; bx += 2) {
                ctx.beginPath(); ctx.moveTo(bx, -22); ctx.lineTo(bx, 28); ctx.stroke();
              }
              ctx.fillStyle = '#ffd700'; ctx.fillRect(10, -6, 12, 2);
              ctx.shadowBlur = 0; ctx.fillStyle = '#fff8a0';
              ctx.beginPath(); ctx.arc(16, -26, 3, 0, Math.PI * 2); ctx.fill();
              ctx.fillStyle = '#ffd700';
              [[0,-4],[4,3],[-4,3],[2,-3],[-2,-3]].forEach(([ox,oy]) => {
                ctx.beginPath(); ctx.arc(16+ox, -26+oy, 1, 0, Math.PI*2); ctx.fill();
              });
              ctx.shadowBlur = 0;
              ctx.restore();
              break;
            }
          }
        });

        npcs.forEach(npc => {
          const screenX = (npc.x - camera.x) * TILE_SIZE, screenY = (npc.y - camera.y) * TILE_SIZE;
          if (screenX > -TILE_SIZE * 2 && screenX < canvas.width + TILE_SIZE * 2 && screenY > -TILE_SIZE * 2 && screenY < canvas.height + TILE_SIZE * 2) {
            // All sprite drawing scaled 2× inside this block
            ctx.save(); ctx.translate(screenX, screenY); ctx.scale(SCALE, SCALE);
            if (npc.isSerpent) {
              ctx.fillStyle = npc.color;
              const wave = Math.sin(gameTime * 0.2) * 3;
              for (let i = 0; i < 3; i++) { ctx.beginPath(); ctx.arc(16 - i * 7, 20 + Math.sin(gameTime * 0.2 + i) * 2, 5 - i, 0, Math.PI * 2); ctx.fill(); }
              ctx.beginPath(); ctx.arc(22, 18 + wave, 6, 0, Math.PI * 2); ctx.fill();
              ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(25, 16 + wave, 2, 0, Math.PI * 2); ctx.fill();
            } else if (npc.isAngel) {
              ctx.shadowColor = '#ffffff'; ctx.shadowBlur = 8;
              ctx.fillStyle = '#fff8dc';
              ctx.beginPath(); ctx.ellipse(3,  15, 8, 11, -0.3, 0, Math.PI * 2); ctx.fill();
              ctx.beginPath(); ctx.ellipse(29, 15, 8, 11,  0.3, 0, Math.PI * 2); ctx.fill();
              ctx.shadowBlur = 0;
              drawCharacterSprite(ctx, 0, 0, {
                walkFrame: npc.walkFrame, isMoving: npc.isMoving, direction: npc.direction || 'down',
                hairColor: '#1a1a1a', bodyColor: '#ffffff', skinColor: SKIN_COLOR,
                isEve: false, showClothes: false, gameTime,
              });
              ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2;
              ctx.beginPath(); ctx.ellipse(16, -3, 8, 3, 0, 0, Math.PI * 2); ctx.stroke();
            } else {
              const showClothes = npc.hasClothes || (npc.clothesBlink > 0 && Math.floor(npc.clothesBlink * 3) % 2 === 0);
              drawCharacterSprite(ctx, 0, 0, {
                walkFrame: npc.walkFrame, isMoving: npc.isMoving, direction: npc.direction || 'down',
                hairColor: npc.hairColor, bodyColor: npc.isEve ? '#c07080' : '#6b8c42', skinColor: SKIN_COLOR,
                isEve: npc.isEve, showClothes,
                holdingFruit: npc.holdingFruit, isEating: npc.isEating,
                hasGlory: npc.hasGlory, gameTime,
              });
            }
            ctx.restore();
            // Name tag and speech bubble drawn at screen coords (outside scale block)
            const cx = screenX + TILE_SIZE / 2;
            if (!showDialogue && gamePhase === PHASES.EXPLORE) drawSpeechBubble(ctx, cx, screenY, npc.thoughts[npc.currentThought], npc.isSerpent);
            const nameText = npc.hasSpoken ? `✓ ${npc.name}` : npc.name;
            ctx.font = 'bold 14px sans-serif';
            const nameWidth = ctx.measureText(nameText).width + 12;
            const nameBoxH = 20, nameBoxY = screenY + 68;
            ctx.fillStyle = npc.hasSpoken ? 'rgba(0,100,0,0.85)' : 'rgba(0,0,0,0.75)';
            ctx.beginPath();
            ctx.roundRect(cx - nameWidth / 2, nameBoxY, nameWidth, nameBoxH, 5);
            ctx.fill();
            ctx.fillStyle = npc.isSerpent ? '#aaffaa' : '#fff';
            ctx.fillText(nameText, cx - nameWidth / 2 + 6, nameBoxY + 14);
          }
        });

        if (gamePhase === PHASES.EXPLORE) {
          const playerScreenX = (player.x - camera.x) * TILE_SIZE, playerScreenY = (player.y - camera.y) * TILE_SIZE;
          ctx.save(); ctx.translate(playerScreenX, playerScreenY); ctx.scale(SCALE, SCALE);
          drawCharacterSprite(ctx, 0, 0, {
            walkFrame: player.walkFrame, isMoving: player.isMoving, direction: player.direction,
            hairColor: '#1a1a1a', bodyColor: '#4169e1', skinColor: SKIN_COLOR,
            gameTime,
          });
          ctx.restore();
        }

        if (gamePhase !== PHASES.EXPLORE && gamePhase !== PHASES.COMPLETE) {
          const chavvah = npcs.find(n => n.id === 'chavvah');
          if (chavvah) setCamera({ x: Math.max(0, Math.min(chavvah.x - vp.w / 2, MAP_WIDTH - vp.w)), y: Math.max(0, Math.min(chavvah.y - vp.h / 2, MAP_HEIGHT - vp.h)) });
        }
      }, [map, player, npcs, camera, showDialogue, gameTime, gamePhase]);

      const spokenCount = npcs.filter(n => ['adam', 'chavvah', 'nachash'].includes(n.id) && n.hasSpoken).length;

      return (
        <div className="game-container">
          <h1 className="title">BERE'SHIYTH: In The Beginning</h1>
          <canvas ref={canvasRef} />

          {showDialogue && (
            <div className="dialogue-box">
              <div className="dialogue-header">
                <span className="dialogue-name">{showDialogue.name}</span>
                <span className="dialogue-counter">{showDialogue.currentDialogue + 1}/{npcs.find(n => n.id === showDialogue.id)?.dialogue.length}</span>
              </div>
              <p className="dialogue-text">{npcs.find(n => n.id === showDialogue.id)?.dialogue[showDialogue.currentDialogue]}</p>
              <button className="btn" onClick={advanceDialogue}>
                {showDialogue.currentDialogue < (npcs.find(n => n.id === showDialogue.id)?.dialogue.length || 1) - 1 ? 'Next ▶' : 'Close ✓'}
              </button>
            </div>
          )}

          {showSceneText && !showDialogue && (
            <div className="dialogue-box">
              <p className="scene-text">{sceneText}</p>
              <button className="btn" onClick={() => { if (gamePhase !== PHASES.EXPLORE) advanceScene(); else setShowSceneText(false); }}>
                {gamePhase === PHASES.EXPLORE ? 'Begin ▶' : 'Continue ▶'}
              </button>
            </div>
          )}

          {gamePhase === PHASES.EXPLORE && !showDialogue && !showSceneText && (
            <p className="quest-text">Speak to A'dam, Chavvah, and the Nachash ({spokenCount}/3)</p>
          )}

          {gamePhase === PHASES.EXPLORE && !showDialogue && !showSceneText && (
            <div className="controls">
              <div className="dpad">
                <div></div>
                <button className="dpad-btn" onTouchStart={(e) => { e.preventDefault(); handleTouchStart('up'); }} onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }} onMouseDown={() => handleTouchStart('up')} onMouseUp={handleTouchEnd} onMouseLeave={handleTouchEnd}>▲</button>
                <div></div>
                <button className="dpad-btn" onTouchStart={(e) => { e.preventDefault(); handleTouchStart('left'); }} onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }} onMouseDown={() => handleTouchStart('left')} onMouseUp={handleTouchEnd} onMouseLeave={handleTouchEnd}>◀</button>
                <div></div>
                <button className="dpad-btn" onTouchStart={(e) => { e.preventDefault(); handleTouchStart('right'); }} onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }} onMouseDown={() => handleTouchStart('right')} onMouseUp={handleTouchEnd} onMouseLeave={handleTouchEnd}>▶</button>
                <div></div>
                <button className="dpad-btn" onTouchStart={(e) => { e.preventDefault(); handleTouchStart('down'); }} onTouchEnd={(e) => { e.preventDefault(); handleTouchEnd(); }} onMouseDown={() => handleTouchStart('down')} onMouseUp={handleTouchEnd} onMouseLeave={handleTouchEnd}>▼</button>
                <div></div>
              </div>
              <button className="talk-btn" onClick={handleInteraction}>TALK</button>
            </div>
          )}

          {gamePhase !== PHASES.EXPLORE && (
            <p className="phase-indicator">{gamePhase === PHASES.COMPLETE ? '📖 The Fall of Man' : '📖 Scene in Progress...'}</p>
          )}

          <p className="help-text">WASD/Arrows to move • SPACE to interact</p>
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<GenesisGame />);
  </script>
</body>
</html>
